"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Propagation = void 0;
const PropagationTaskStore_1 = require("./PropagationTaskStore");
const DEFAULT_MAX_MESSAGES = 10000;
const DEFAULT_TTL = 30 * 1000;
/**
 * Message propagation logic of a node. Given a message, this class will actively attempt to propagate it to
 * `minPropagationTargets` neighbors until success or TTL expiration.
 *
 * Setting `minPropagationTargets = 0` effectively disables any propagation reattempts. A message will then
 * only be propagated exactly once, to neighbors that are present at that moment, in a fire-and-forget manner.
 */
class Propagation {
    constructor({ getNeighbors, sendToNeighbor, minPropagationTargets, ttl = DEFAULT_TTL, maxMessages = DEFAULT_MAX_MESSAGES }) {
        this.getNeighbors = getNeighbors;
        this.sendToNeighbor = sendToNeighbor;
        this.minPropagationTargets = minPropagationTargets;
        this.activeTaskStore = new PropagationTaskStore_1.PropagationTaskStore(ttl, maxMessages);
    }
    /**
     * Node should invoke this when it learns about a new message
     */
    feedUnseenMessage(message, source) {
        const streamPartId = message.getStreamPartID();
        const targetNeighbors = this.getNeighbors(streamPartId).filter((n) => n !== source);
        targetNeighbors.forEach((neighborId) => {
            this.sendToNeighbor(neighborId, message);
        });
        if (targetNeighbors.length < this.minPropagationTargets) {
            this.activeTaskStore.add({
                message,
                source,
                handledNeighbors: new Set(targetNeighbors)
            });
        }
    }
    /**
     * Node should invoke this when it learns about a new node stream assignment
     */
    onNeighborJoined(neighborId, streamPartId) {
        const tasksOfStream = this.activeTaskStore.get(streamPartId);
        tasksOfStream.forEach(({ handledNeighbors, source, message }) => {
            if (!handledNeighbors.has(neighborId) && neighborId !== source) {
                this.sendToNeighbor(neighborId, message);
                handledNeighbors.add(neighborId);
                if (handledNeighbors.size >= this.minPropagationTargets) {
                    this.activeTaskStore.delete(message.messageId);
                }
            }
        });
    }
}
exports.Propagation = Propagation;
//# sourceMappingURL=Propagation.js.map