/// <reference types="node" />
import { EventEmitter } from 'events';
import { MessageLayer, StreamPartID } from 'streamr-client-protocol';
import { NodeToNode } from '../../protocol/NodeToNode';
import { NodeToTracker } from '../../protocol/NodeToTracker';
import { MetricsContext } from '../../helpers/MetricsContext';
import { StreamPartManager } from './StreamPartManager';
import { PeerInfo } from '../../connection/PeerInfo';
import type { TrackerId } from '../tracker/Tracker';
import { TrackerManagerOptions } from './TrackerManager';
export declare type NodeId = string;
export declare enum Event {
    NODE_CONNECTED = "streamr:node:node-connected",
    NODE_DISCONNECTED = "streamr:node:node-disconnected",
    MESSAGE_RECEIVED = "streamr:node:message-received",
    UNSEEN_MESSAGE_RECEIVED = "streamr:node:unseen-message-received",
    NODE_SUBSCRIBED = "streamr:node:subscribed-successfully",
    NODE_UNSUBSCRIBED = "streamr:node:node-unsubscribed",
    PUBLISH_STREAM_ACCEPTED = "streamr:node:publish-stream-accepted",
    PUBLISH_STREAM_REJECTED = "streamr:node:node-stream-rejected",
    ONE_WAY_CONNECTION_CLOSED = "stream:node-one-way-connection-closed"
}
export interface NodeOptions extends TrackerManagerOptions {
    protocols: {
        nodeToNode: NodeToNode;
        nodeToTracker: NodeToTracker;
    };
    peerInfo: PeerInfo;
    metricsContext?: MetricsContext;
    bufferTimeoutInMs?: number;
    bufferMaxSize?: number;
    disconnectionWaitTime?: number;
    nodeConnectTimeout?: number;
    acceptProxyConnections?: boolean;
}
export interface Node {
    on(event: Event.NODE_CONNECTED, listener: (nodeId: NodeId) => void): this;
    on(event: Event.NODE_DISCONNECTED, listener: (nodeId: NodeId) => void): this;
    on<T>(event: Event.MESSAGE_RECEIVED, listener: (msg: MessageLayer.StreamMessage<T>, nodeId: NodeId) => void): this;
    on<T>(event: Event.UNSEEN_MESSAGE_RECEIVED, listener: (msg: MessageLayer.StreamMessage<T>, nodeId: NodeId) => void): this;
    on(event: Event.NODE_SUBSCRIBED, listener: (nodeId: NodeId, streamPartId: StreamPartID) => void): this;
    on(event: Event.NODE_UNSUBSCRIBED, listener: (nodeId: NodeId, streamPartId: StreamPartID) => void): this;
    on(event: Event.PUBLISH_STREAM_ACCEPTED, listener: (nodeId: NodeId, streamPartId: StreamPartID) => void): this;
    on(event: Event.PUBLISH_STREAM_REJECTED, listener: (nodeId: NodeId, streamPartId: StreamPartID, reason?: string) => void): this;
    on(event: Event.ONE_WAY_CONNECTION_CLOSED, listener: (nodeId: NodeId, streamPartId: StreamPartID) => void): this;
}
export declare class Node extends EventEmitter {
    /** @internal */
    readonly peerInfo: PeerInfo;
    protected readonly nodeToNode: NodeToNode;
    private readonly nodeConnectTimeout;
    private readonly started;
    protected readonly streamPartManager: StreamPartManager;
    private readonly disconnectionManager;
    private readonly propagation;
    private readonly trackerManager;
    private readonly consecutiveDeliveryFailures;
    private readonly metricsContext;
    private readonly metrics;
    protected extraMetadata: Record<string, unknown>;
    private readonly acceptProxyConnections;
    private readonly proxyStreamConnectionManager;
    constructor(opts: NodeOptions);
    start(): void;
    subscribeToStreamIfHaveNotYet(streamPartId: StreamPartID, sendStatus?: boolean): void;
    unsubscribeFromStream(streamPartId: StreamPartID, sendStatus?: boolean): void;
    subscribeToStreamPartOnNodes(nodeIds: NodeId[], streamPartId: StreamPartID, trackerId: TrackerId, reattempt: boolean): Promise<PromiseSettledResult<NodeId>[]>;
    openOutgoingStreamConnection(streamPartId: StreamPartID, contactNodeId: string): Promise<void>;
    closeOutgoingStreamConnection(streamPartId: StreamPartID, contactNodeId: string): void;
    onDataReceived(streamMessage: MessageLayer.StreamMessage, source?: NodeId | null): void | never;
    stop(): Promise<unknown>;
    private subscribeToStreamPartOnNode;
    private unsubscribeFromStreamPartOnNode;
    private onNodeDisconnected;
    getStreamParts(): Iterable<StreamPartID>;
    getNeighbors(): ReadonlyArray<NodeId>;
    getNodeId(): NodeId;
    getMetricsContext(): MetricsContext;
}
