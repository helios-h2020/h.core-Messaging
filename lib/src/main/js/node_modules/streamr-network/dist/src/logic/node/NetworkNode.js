"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkNode = void 0;
const Node_1 = require("./Node");
/*
Convenience wrapper for building client-facing functionality. Used by broker.
 */
class NetworkNode extends Node_1.Node {
    constructor(opts) {
        const networkOpts = {
            ...opts
        };
        super(networkOpts);
    }
    setExtraMetadata(metadata) {
        this.extraMetadata = metadata;
    }
    publish(streamMessage) {
        this.onDataReceived(streamMessage);
    }
    async joinStreamPartAsPurePublisher(streamPartId, contactNodeId) {
        let resolveHandler;
        let rejectHandler;
        await Promise.all([
            new Promise((resolve, reject) => {
                resolveHandler = (node, stream) => {
                    if (node === contactNodeId && stream === streamPartId) {
                        resolve();
                    }
                };
                rejectHandler = (node, stream) => {
                    if (node === contactNodeId && stream === streamPartId) {
                        reject(`Joining stream as pure publisher failed on contact-node ${contactNodeId} for stream ${streamPartId}`);
                    }
                };
                this.on(Node_1.Event.PUBLISH_STREAM_ACCEPTED, resolveHandler);
                this.on(Node_1.Event.PUBLISH_STREAM_REJECTED, rejectHandler);
            }),
            this.openOutgoingStreamConnection(streamPartId, contactNodeId)
        ]).finally(() => {
            this.off(Node_1.Event.PUBLISH_STREAM_ACCEPTED, resolveHandler);
            this.off(Node_1.Event.PUBLISH_STREAM_REJECTED, rejectHandler);
        });
    }
    async leavePurePublishingStreamPart(streamPartId, contactNodeId) {
        await this.closeOutgoingStreamConnection(streamPartId, contactNodeId);
    }
    addMessageListener(cb) {
        this.on(Node_1.Event.UNSEEN_MESSAGE_RECEIVED, cb);
    }
    removeMessageListener(cb) {
        this.off(Node_1.Event.UNSEEN_MESSAGE_RECEIVED, cb);
    }
    subscribe(streamPartId) {
        this.subscribeToStreamIfHaveNotYet(streamPartId);
    }
    unsubscribe(streamPartId) {
        this.unsubscribeFromStream(streamPartId);
    }
    getNeighborsForStreamPart(streamPartId) {
        return this.streamPartManager.getNeighborsForStreamPart(streamPartId);
    }
    getRtt(nodeId) {
        return this.nodeToNode.getRtts()[nodeId];
    }
}
exports.NetworkNode = NetworkNode;
//# sourceMappingURL=NetworkNode.js.map