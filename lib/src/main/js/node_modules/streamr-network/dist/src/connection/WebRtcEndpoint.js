"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRtcEndpoint = void 0;
const events_1 = require("events");
const IWebRtcEndpoint_1 = require("./IWebRtcEndpoint");
const Logger_1 = require("../helpers/Logger");
const PeerInfo_1 = require("./PeerInfo");
const DeferredConnectionAttempt_1 = require("./DeferredConnectionAttempt");
const WebRtcConnection_1 = require("./WebRtcConnection");
const MessageQueue_1 = require("./MessageQueue");
const NameDirectory_1 = require("../NameDirectory");
const uuid_1 = require("uuid");
const AddressTools_1 = require("../helpers/AddressTools");
class WebRtcError extends Error {
    constructor(msg) {
        super(msg);
        // exclude this constructor from stack trace
        Error.captureStackTrace(this, WebRtcError);
    }
}
class WebRtcEndpoint extends events_1.EventEmitter {
    constructor(peerInfo, stunUrls, rtcSignaller, metricsContext, negotiatedProtocolVersions, connectionFactory, newConnectionTimeout = 15000, pingInterval = 5 * 1000, webrtcDatachannelBufferThresholdLow = 2 ** 15, webrtcDatachannelBufferThresholdHigh = 2 ** 17, webrtcDisallowPrivateAddresses = false, maxMessageSize = 1048576) {
        super();
        this.stopped = false;
        this.peerInfo = peerInfo;
        this.stunUrls = stunUrls;
        this.rtcSignaller = rtcSignaller;
        this.negotiatedProtocolVersions = negotiatedProtocolVersions;
        this.connectionFactory = connectionFactory;
        this.connections = {};
        this.messageQueues = {};
        this.newConnectionTimeout = newConnectionTimeout;
        this.pingInterval = pingInterval;
        this.logger = new Logger_1.Logger(module);
        this.bufferThresholdLow = webrtcDatachannelBufferThresholdLow;
        this.bufferThresholdHigh = webrtcDatachannelBufferThresholdHigh;
        this.disallowPrivateAddresses = webrtcDisallowPrivateAddresses;
        this.maxMessageSize = maxMessageSize;
        rtcSignaller.setOfferListener(async (options) => {
            this.onRtcOfferFromSignaller(options);
        });
        rtcSignaller.setAnswerListener((options) => {
            this.onRtcAnswerFromSignaller(options);
        });
        rtcSignaller.setIceCandidateListener((options) => {
            this.onIceCandidateFromSignaller(options);
        });
        rtcSignaller.setConnectListener(async (options) => {
            this.onConnectFromSignaller(options);
        });
        rtcSignaller.setErrorListener((options) => {
            this.onErrorFromSignaller(options);
        });
        this.metrics = metricsContext.create('WebRtcEndpoint')
            .addRecordedMetric('inSpeed')
            .addRecordedMetric('outSpeed')
            .addRecordedMetric('msgSpeed')
            .addRecordedMetric('msgInSpeed')
            .addRecordedMetric('msgOutSpeed')
            .addRecordedMetric('open')
            .addRecordedMetric('close')
            .addRecordedMetric('sendFailed')
            .addRecordedMetric('failedConnection')
            .addQueriedMetric('connections', () => Object.keys(this.connections).length)
            .addQueriedMetric('pendingConnections', () => {
            return Object.values(this.connections).filter((c) => !c.isOpen()).length;
        })
            .addQueriedMetric('totalWebSocketBuffer', () => {
            return Object.values(this.connections).reduce((total, c) => total + c.getBufferedAmount(), 0);
        })
            .addQueriedMetric('messageQueueSize', () => {
            return Object.values(this.connections).reduce((total, c) => total + c.getQueueSize(), 0);
        });
        this.startConnectionStatusReport();
    }
    startConnectionStatusReport() {
        const getPeerNameList = (peerIds) => {
            return peerIds.map((peerId) => NameDirectory_1.NameDirectory.getName(peerId)).join(',');
        };
        const STATUS_REPORT_INTERVAL_MS = 5 * 60 * 1000;
        this.statusReportTimer = setInterval(() => {
            const connectedPeerIds = [];
            const pendingPeerIds = [];
            for (const peerId of Object.keys(this.connections)) {
                const lastState = this.connections[peerId].getLastState();
                if (lastState === 'connected') {
                    connectedPeerIds.push(peerId);
                }
                else if (lastState === 'connecting') {
                    pendingPeerIds.push(peerId);
                }
            }
            const suffix = (pendingPeerIds.length > 0) ? ', still trying to connect: %s' : '';
            this.logger.info(`Successfully connected to %d peers (%s)${suffix}`, connectedPeerIds.length, getPeerNameList(connectedPeerIds), getPeerNameList(pendingPeerIds));
        }, STATUS_REPORT_INTERVAL_MS);
    }
    createConnection(targetPeerId, routerId, deferredConnectionAttempt) {
        const messageQueue = this.messageQueues[targetPeerId] = this.messageQueues[targetPeerId] || new MessageQueue_1.MessageQueue(this.maxMessageSize);
        const connectionOptions = {
            selfId: this.peerInfo.peerId,
            targetPeerId,
            routerId,
            stunUrls: this.stunUrls,
            bufferThresholdHigh: this.bufferThresholdHigh,
            bufferThresholdLow: this.bufferThresholdLow,
            messageQueue,
            deferredConnectionAttempt: deferredConnectionAttempt || new DeferredConnectionAttempt_1.DeferredConnectionAttempt(),
            newConnectionTimeout: this.newConnectionTimeout,
            pingInterval: this.pingInterval,
        };
        const connection = this.connectionFactory.createConnection(connectionOptions);
        if (connection.isOffering()) {
            connection.once('localDescription', (type, description) => {
                this.rtcSignaller.sendRtcOffer(routerId, connection.getPeerId(), connection.getConnectionId(), description);
                this.attemptProtocolVersionValidation(connection);
            });
        }
        else {
            connection.once('localDescription', (type, description) => {
                this.rtcSignaller.sendRtcAnswer(routerId, connection.getPeerId(), connection.getConnectionId(), description);
                this.attemptProtocolVersionValidation(connection);
            });
        }
        connection.on('localCandidate', (candidate, mid) => {
            this.rtcSignaller.sendRtcIceCandidate(routerId, connection.getPeerId(), connection.getConnectionId(), candidate, mid);
        });
        connection.once('open', () => {
            this.emit(IWebRtcEndpoint_1.Event.PEER_CONNECTED, connection.getPeerInfo());
            this.metrics.record('open', 1);
        });
        connection.on('message', (message) => {
            this.emit(IWebRtcEndpoint_1.Event.MESSAGE_RECEIVED, connection.getPeerInfo(), message);
            this.metrics.record('inSpeed', message.length);
            this.metrics.record('msgSpeed', 1);
            this.metrics.record('msgInSpeed', 1);
        });
        connection.once('close', () => {
            if (this.connections[targetPeerId] === connection) {
                // if endpoint.close() was called, connection has already been
                // removed and possibly replaced. This check avoids deleting new
                // connection.
                delete this.connections[targetPeerId];
            }
            this.negotiatedProtocolVersions.removeNegotiatedProtocolVersion(targetPeerId);
            this.emit(IWebRtcEndpoint_1.Event.PEER_DISCONNECTED, connection.getPeerInfo());
            connection.removeAllListeners();
            this.metrics.record('close', 1);
        });
        connection.on('bufferLow', () => {
            this.emit(IWebRtcEndpoint_1.Event.LOW_BACK_PRESSURE, connection.getPeerInfo());
        });
        connection.on('bufferHigh', () => {
            this.emit(IWebRtcEndpoint_1.Event.HIGH_BACK_PRESSURE, connection.getPeerInfo());
        });
        connection.on('failed', () => {
            this.metrics.record('failedConnection', 1);
        });
        return connection;
    }
    onRtcOfferFromSignaller({ routerId, originatorInfo, description, connectionId }) {
        const { peerId } = originatorInfo;
        let connection;
        if (!this.connections[peerId]) {
            connection = this.createConnection(peerId, routerId, null);
            try {
                connection.connect();
            }
            catch (e) {
                this.logger.warn(e);
            }
            this.connections[peerId] = connection;
        }
        else if (this.connections[peerId].getConnectionId() !== 'none') {
            connection = this.replaceConnection(peerId, routerId);
        }
        else {
            connection = this.connections[peerId];
        }
        connection.setPeerInfo(PeerInfo_1.PeerInfo.fromObject(originatorInfo));
        connection.setConnectionId(connectionId);
        connection.setRemoteDescription(description, 'offer');
    }
    onRtcAnswerFromSignaller({ originatorInfo, description, connectionId }) {
        const { peerId } = originatorInfo;
        const connection = this.connections[peerId];
        if (!connection) {
            this.logger.debug('unexpected rtcAnswer from %s: %s (no connection)', peerId, description);
        }
        else if (connection.getConnectionId() !== connectionId) {
            this.logger.debug('unexpected rtcAnswer from %s (connectionId mismatch %s !== %s)', peerId, connection.getConnectionId(), connectionId);
        }
        else {
            connection.setPeerInfo(PeerInfo_1.PeerInfo.fromObject(originatorInfo));
            connection.setRemoteDescription(description, 'answer');
            this.attemptProtocolVersionValidation(connection);
        }
    }
    isIceCandidateAllowed(candidate) {
        if (this.disallowPrivateAddresses) {
            const address = (0, AddressTools_1.getAddressFromIceCandidate)(candidate);
            if (address && (0, AddressTools_1.isPrivateIPv4)(address)) {
                return false;
            }
        }
        return true;
    }
    onIceCandidateFromSignaller({ originatorInfo, candidate, mid, connectionId }) {
        const { peerId } = originatorInfo;
        const connection = this.connections[peerId];
        if (!connection) {
            this.logger.debug('unexpected iceCandidate from %s: %s (no connection)', peerId, candidate);
        }
        else if (connection.getConnectionId() !== connectionId) {
            this.logger.debug('unexpected iceCandidate from %s (connectionId mismatch %s !== %s)', peerId, connection.getConnectionId(), connectionId);
        }
        else {
            if (this.isIceCandidateAllowed(candidate)) {
                connection.addRemoteCandidate(candidate, mid);
            }
        }
    }
    onErrorFromSignaller({ targetNode, errorCode }) {
        const error = new WebRtcError(`RTC error ${errorCode} while attempting to signal with node ${targetNode}`);
        const connection = this.connections[targetNode];
        // treat rtcSignaller errors as connection errors.
        if (connection) {
            connection.close(error);
        }
    }
    onConnectFromSignaller({ originatorInfo, routerId }) {
        const { peerId } = originatorInfo;
        if (this.connections[peerId]) {
            this.replaceConnection(peerId, routerId, (0, uuid_1.v4)());
        }
        else {
            this.connect(peerId, routerId, true).then(() => {
                this.logger.trace('unattended connectListener induced connection from %s connected', peerId);
                return peerId;
            }).catch((err) => {
                this.logger.trace('connectListener induced connection from %s failed, reason %s', peerId, err);
            });
        }
    }
    replaceConnection(peerId, routerId, newConnectionId) {
        // Close old connection
        const conn = this.connections[peerId];
        let deferredConnectionAttempt = null;
        if (conn.getDeferredConnectionAttempt()) {
            deferredConnectionAttempt = conn.stealDeferredConnectionAttempt();
        }
        delete this.connections[peerId];
        conn.close();
        // Set up new connection
        const connection = this.createConnection(peerId, routerId, deferredConnectionAttempt);
        if (newConnectionId) {
            connection.setConnectionId(newConnectionId);
        }
        try {
            connection.connect();
        }
        catch (e) {
            this.logger.warn(e);
        }
        this.connections[peerId] = connection;
        return connection;
    }
    async connect(targetPeerId, routerId, trackerInstructed = true) {
        // Prevent new connections from being opened when WebRtcEndpoint has been closed
        if (this.stopped) {
            return Promise.reject(new WebRtcError('WebRtcEndpoint has been stopped'));
        }
        if (this.connections[targetPeerId]) {
            const connection = this.connections[targetPeerId];
            const lastState = connection.getLastState();
            const deferredConnectionAttempt = connection.getDeferredConnectionAttempt();
            this.logger.trace('%s has already connection for %s. state: %s', (0, WebRtcConnection_1.isOffering)(this.peerInfo.peerId, targetPeerId) ? 'offerer' : 'answerer', NameDirectory_1.NameDirectory.getName(targetPeerId), lastState);
            if (lastState === 'connected') {
                return Promise.resolve(targetPeerId);
            }
            else if (deferredConnectionAttempt) {
                return deferredConnectionAttempt.getPromise();
            }
            else {
                throw new Error(`unexpected deferedConnectionAttempt == null ${connection.getPeerId()}`);
            }
        }
        const connection = this.createConnection(targetPeerId, routerId, null);
        if (connection.isOffering()) {
            connection.setConnectionId((0, uuid_1.v4)());
        }
        this.connections[targetPeerId] = connection;
        connection.connect();
        if (!trackerInstructed && !connection.isOffering()) {
            // If we are non-offerer and this connection was not instructed by the tracker, we need
            // to let the offering side know about it so it can send us the initial offer message.
            this.rtcSignaller.sendRtcConnect(routerId, connection.getPeerId());
        }
        const deferredAttempt = connection.getDeferredConnectionAttempt();
        if (connection.getLastState() == 'connected') {
            return targetPeerId;
        }
        if (deferredAttempt) {
            return deferredAttempt.getPromise();
        }
        else {
            throw new WebRtcError(`disconnected ${connection.getPeerId()}`);
        }
    }
    async send(targetPeerId, message) {
        if (!this.connections[targetPeerId]) {
            throw new WebRtcError(`Not connected to ${targetPeerId}.`);
        }
        try {
            await this.connections[targetPeerId].send(message);
        }
        catch (err) {
            this.metrics.record('sendFailed', 1);
            throw err;
        }
        this.metrics.record('outSpeed', message.length);
        this.metrics.record('msgSpeed', 1);
        this.metrics.record('msgOutSpeed', 1);
    }
    attemptProtocolVersionValidation(connection) {
        try {
            this.negotiatedProtocolVersions.negotiateProtocolVersion(connection.getPeerId(), connection.getPeerInfo().controlLayerVersions, connection.getPeerInfo().messageLayerVersions);
        }
        catch (err) {
            this.logger.debug(err);
            this.close(connection.getPeerId(), `No shared protocol versions with node: ${connection.getPeerId()}`);
        }
    }
    close(receiverPeerId, reason) {
        const connection = this.connections[receiverPeerId];
        if (connection) {
            this.logger.debug('close connection to %s due to %s', NameDirectory_1.NameDirectory.getName(receiverPeerId), reason);
            delete this.connections[receiverPeerId];
            connection.close();
        }
    }
    getRtts() {
        const rtts = {};
        Object.entries(this.connections).forEach(([targetPeerId, connection]) => {
            const rtt = connection.getRtt();
            if (rtt !== undefined && rtt !== null) {
                rtts[targetPeerId] = rtt;
            }
        });
        return rtts;
    }
    getPeerInfo() {
        return this.peerInfo;
    }
    getNegotiatedMessageLayerProtocolVersionOnNode(peerId) {
        var _a;
        return (_a = this.negotiatedProtocolVersions.getNegotiatedProtocolVersions(peerId)) === null || _a === void 0 ? void 0 : _a.messageLayerVersion;
    }
    getNegotiatedControlLayerProtocolVersionOnNode(peerId) {
        var _a;
        return (_a = this.negotiatedProtocolVersions.getNegotiatedProtocolVersions(peerId)) === null || _a === void 0 ? void 0 : _a.controlLayerVersion;
    }
    getDefaultMessageLayerProtocolVersion() {
        return this.negotiatedProtocolVersions.getDefaultProtocolVersions().messageLayerVersion;
    }
    getDefaultControlLayerProtocolVersion() {
        return this.negotiatedProtocolVersions.getDefaultProtocolVersions().controlLayerVersion;
    }
    /**
     * @deprecated
     */
    getAddress() {
        return this.peerInfo.peerId;
    }
    stop() {
        this.stopped = true;
        const { connections, messageQueues } = this;
        this.connections = {};
        this.messageQueues = {};
        this.rtcSignaller.setOfferListener(() => { });
        this.rtcSignaller.setAnswerListener(() => { });
        this.rtcSignaller.setIceCandidateListener(() => { });
        this.rtcSignaller.setErrorListener(() => { });
        this.rtcSignaller.setConnectListener(() => { });
        clearInterval(this.statusReportTimer);
        this.removeAllListeners();
        Object.values(connections).forEach((connection) => connection.close());
        Object.values(messageQueues).forEach((queue) => queue.clear());
        this.connectionFactory.cleanUp();
    }
    getAllConnectionNodeIds() {
        return Object.keys(this.connections);
    }
}
exports.WebRtcEndpoint = WebRtcEndpoint;
//# sourceMappingURL=WebRtcEndpoint.js.map