"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyStreamConnectionManager = void 0;
const Node_1 = require("./Node");
const PromiseTools_1 = require("../../helpers/PromiseTools");
const LoggerNode_1 = require("../../helpers/logger/LoggerNode");
const logger = new LoggerNode_1.Logger(module);
var State;
(function (State) {
    State[State["NEGOTIATING"] = 0] = "NEGOTIATING";
    State[State["ACCEPTED"] = 1] = "ACCEPTED";
    State[State["RENEGOTIATING"] = 2] = "RENEGOTIATING";
})(State || (State = {}));
const DEFAULT_RECONNECTION_TIMEOUT = 10 * 1000;
class ProxyStreamConnectionManager {
    constructor(opts) {
        this.trackerManager = opts.trackerManager;
        this.streamPartManager = opts.streamPartManager;
        this.nodeToNode = opts.nodeToNode;
        this.node = opts.node;
        this.nodeConnectTimeout = opts.nodeConnectTimeout;
        this.acceptProxyConnections = opts.acceptProxyConnections;
        this.connections = new Map();
    }
    addConnection(streamPartId, nodeId) {
        if (!this.connections.has(streamPartId)) {
            this.connections.set(streamPartId, new Map());
        }
        this.connections.get(streamPartId).set(nodeId, {
            state: State.NEGOTIATING
        });
    }
    removeConnection(streamPartId, nodeId) {
        if (this.connections.has(streamPartId)) {
            this.connections.get(streamPartId).delete(nodeId);
            if (this.connections.get(streamPartId).size === 0) {
                this.connections.delete(streamPartId);
            }
        }
        this.streamPartManager.removeNodeFromStreamPart(streamPartId, nodeId);
        // Finally if the stream has no neighbors or in/out connections, remove the stream
        if (this.streamPartManager.getAllNodesForStreamPart(streamPartId).length === 0
            && !this.connections.has(streamPartId)
            && this.streamPartManager.isBehindProxy(streamPartId)) {
            this.streamPartManager.removeStreamPart(streamPartId);
        }
    }
    hasConnection(nodeId, streamPartId) {
        if (!this.connections.has(streamPartId)) {
            return false;
        }
        return this.connections.get(streamPartId).has(nodeId);
    }
    getConnection(nodeId, streamPartId) {
        return this.connections.get(streamPartId).get(nodeId);
    }
    async openOutgoingStreamConnection(streamPartId, targetNodeId) {
        const trackerId = this.trackerManager.getTrackerId(streamPartId);
        try {
            if (!this.streamPartManager.isSetUp(streamPartId)) {
                this.streamPartManager.setUpStreamPart(streamPartId, true);
            }
            else if (!this.streamPartManager.isBehindProxy(streamPartId)) {
                const reason = `Could not open a proxy outgoing stream connection ${streamPartId}, bidirectional stream already exists`;
                logger.warn(reason);
                this.node.emit(Node_1.Event.PUBLISH_STREAM_REJECTED, targetNodeId, streamPartId, reason);
                return;
            }
            else if (this.streamPartManager.hasOutOnlyConnection(streamPartId, targetNodeId)) {
                const reason = `Could not open a proxy outgoing stream connection ${streamPartId}, proxy stream connection already exists`;
                logger.warn(reason);
                this.node.emit(Node_1.Event.PUBLISH_STREAM_REJECTED, targetNodeId, streamPartId, reason);
                return;
            }
            else if (this.hasConnection(targetNodeId, streamPartId)) {
                const reason = `Could not open a proxy outgoing stream connection ${streamPartId}, a connection already exists`;
                logger.warn(reason);
                return;
            }
            this.addConnection(streamPartId, targetNodeId);
            await this.connectAndNegotiate(streamPartId, targetNodeId);
        }
        catch (err) {
            logger.warn(`Failed to create a proxy outgoing stream connection to ${targetNodeId} for stream ${streamPartId}:\n${err}`);
            this.removeConnection(streamPartId, targetNodeId);
            this.node.emit(Node_1.Event.PUBLISH_STREAM_REJECTED, targetNodeId, streamPartId, err);
        }
        finally {
            this.trackerManager.disconnectFromSignallingOnlyTracker(trackerId);
        }
    }
    async connectAndNegotiate(streamPartId, targetNodeId) {
        const trackerId = this.trackerManager.getTrackerId(streamPartId);
        const trackerAddress = this.trackerManager.getTrackerAddress(streamPartId);
        await this.trackerManager.connectToSignallingOnlyTracker(trackerId, trackerAddress);
        await (0, PromiseTools_1.promiseTimeout)(this.nodeConnectTimeout, this.nodeToNode.connectToNode(targetNodeId, trackerId, false));
        await this.nodeToNode.requestPublishOnlyStreamConnection(targetNodeId, streamPartId);
    }
    async closeOutgoingStreamConnection(streamPartId, targetNodeId) {
        if (this.streamPartManager.isSetUp(streamPartId) && this.streamPartManager.hasOutOnlyConnection(streamPartId, targetNodeId)) {
            clearTimeout(this.getConnection(targetNodeId, streamPartId).reconnectionTimer);
            this.removeConnection(streamPartId, targetNodeId);
            await this.nodeToNode.leaveStreamOnNode(targetNodeId, streamPartId);
            this.node.emit(Node_1.Event.ONE_WAY_CONNECTION_CLOSED, targetNodeId, streamPartId);
        }
        else {
            const reason = `A proxy outgoing stream connection for ${streamPartId} on node ${targetNodeId} does not exist`;
            logger.warn(reason);
            throw reason;
        }
    }
    processLeaveRequest(message, nodeId) {
        const streamPartId = message.getStreamPartID();
        if (this.streamPartManager.isSetUp(streamPartId) && this.streamPartManager.hasInOnlyConnection(streamPartId, nodeId)) {
            this.removeConnection(streamPartId, nodeId);
            this.node.emit(Node_1.Event.ONE_WAY_CONNECTION_CLOSED, nodeId, streamPartId);
        }
        if (this.streamPartManager.isSetUp(streamPartId) && this.streamPartManager.hasOutOnlyConnection(streamPartId, nodeId)) {
            this.removeConnection(streamPartId, nodeId);
            this.node.emit(Node_1.Event.ONE_WAY_CONNECTION_CLOSED, nodeId, streamPartId);
            logger.info(`Proxy node ${nodeId} closed one-way stream connection for ${streamPartId}`);
        }
    }
    async processPublishStreamRequest(message, nodeId) {
        const streamPartId = message.getStreamPartID();
        // More conditions could be added here, ie. a list of acceptable ids or max limit for number of one-way this
        const isAccepted = this.streamPartManager.isSetUp(streamPartId) && this.acceptProxyConnections;
        if (isAccepted) {
            this.streamPartManager.addInOnlyNeighbor(streamPartId, nodeId);
        }
        await this.nodeToNode.respondToPublishOnlyStreamConnectionRequest(nodeId, streamPartId, isAccepted);
    }
    processPublishStreamResponse(message, nodeId) {
        const streamPartId = message.getStreamPartID();
        if (message.accepted) {
            this.getConnection(nodeId, streamPartId).state = State.ACCEPTED;
            this.streamPartManager.addOutOnlyNeighbor(streamPartId, nodeId);
            this.node.emit(Node_1.Event.PUBLISH_STREAM_ACCEPTED, nodeId, streamPartId);
        }
        else {
            this.removeConnection(streamPartId, nodeId);
            this.node.emit(Node_1.Event.PUBLISH_STREAM_REJECTED, nodeId, streamPartId, `Target node ${nodeId} rejected publish only stream connection ${streamPartId}`);
        }
    }
    async reconnect(targetNodeId, streamPartId) {
        const connection = this.getConnection(targetNodeId, streamPartId);
        if (connection.state !== State.RENEGOTIATING) {
            connection.state = State.RENEGOTIATING;
        }
        const trackerId = this.trackerManager.getTrackerId(streamPartId);
        try {
            await this.connectAndNegotiate(streamPartId, targetNodeId);
            logger.trace(`Successful proxy stream reconnection to ${targetNodeId}`);
            connection.state = State.ACCEPTED;
            if (connection.reconnectionTimer !== undefined) {
                clearTimeout(connection.reconnectionTimer);
            }
        }
        catch (err) {
            logger.warn(`Proxy stream reconnection attempt to ${targetNodeId} failed with error: ${err}`);
            connection.reconnectionTimer = setTimeout(async () => {
                await this.reconnect(targetNodeId, streamPartId);
            }, DEFAULT_RECONNECTION_TIMEOUT);
        }
        finally {
            this.trackerManager.disconnectFromSignallingOnlyTracker(trackerId);
        }
    }
    stop() {
        this.connections.forEach((streamPart) => {
            streamPart.forEach((connection) => {
                if (connection.reconnectionTimer !== undefined) {
                    clearTimeout(connection.reconnectionTimer);
                }
            });
        });
        this.connections.clear();
    }
}
exports.ProxyStreamConnectionManager = ProxyStreamConnectionManager;
//# sourceMappingURL=ProxyStreamConnectionManager.js.map