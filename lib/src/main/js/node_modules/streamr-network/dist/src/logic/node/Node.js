"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = exports.Event = void 0;
const events_1 = require("events");
const NodeToNode_1 = require("../../protocol/NodeToNode");
const MetricsContext_1 = require("../../helpers/MetricsContext");
const PromiseTools_1 = require("../../helpers/PromiseTools");
const StreamPartManager_1 = require("./StreamPartManager");
const DuplicateMessageDetector_1 = require("./DuplicateMessageDetector");
const Logger_1 = require("../../helpers/Logger");
const config_1 = require("../tracker/config");
const TrackerManager_1 = require("./TrackerManager");
const Propagation_1 = require("./propagation/Propagation");
const DisconnectionManager_1 = require("./DisconnectionManager");
const ProxyStreamConnectionManager_1 = require("./ProxyStreamConnectionManager");
const logger = new Logger_1.Logger(module);
var Event;
(function (Event) {
    Event["NODE_CONNECTED"] = "streamr:node:node-connected";
    Event["NODE_DISCONNECTED"] = "streamr:node:node-disconnected";
    Event["MESSAGE_RECEIVED"] = "streamr:node:message-received";
    Event["UNSEEN_MESSAGE_RECEIVED"] = "streamr:node:unseen-message-received";
    Event["NODE_SUBSCRIBED"] = "streamr:node:subscribed-successfully";
    Event["NODE_UNSUBSCRIBED"] = "streamr:node:node-unsubscribed";
    Event["PUBLISH_STREAM_ACCEPTED"] = "streamr:node:publish-stream-accepted";
    Event["PUBLISH_STREAM_REJECTED"] = "streamr:node:node-stream-rejected";
    Event["ONE_WAY_CONNECTION_CLOSED"] = "stream:node-one-way-connection-closed";
})(Event = exports.Event || (exports.Event = {}));
class Node extends events_1.EventEmitter {
    constructor(opts) {
        var _a;
        super();
        this.extraMetadata = {};
        this.nodeToNode = opts.protocols.nodeToNode;
        this.peerInfo = opts.peerInfo;
        this.nodeConnectTimeout = opts.nodeConnectTimeout || 15000;
        this.consecutiveDeliveryFailures = {};
        this.started = new Date().toLocaleString();
        this.acceptProxyConnections = opts.acceptProxyConnections || false;
        this.metricsContext = opts.metricsContext || new MetricsContext_1.MetricsContext('');
        this.metrics = this.metricsContext.create('node')
            .addRecordedMetric('onDataReceived')
            .addRecordedMetric('onDataReceived:invalidNumbering')
            .addRecordedMetric('onDataReceived:gapMismatch')
            .addRecordedMetric('onDataReceived:ignoredDuplicate')
            .addRecordedMetric('propagateMessage')
            .addRecordedMetric('onNodeDisconnect')
            .addFixedMetric('latency');
        this.streamPartManager = new StreamPartManager_1.StreamPartManager();
        this.disconnectionManager = new DisconnectionManager_1.DisconnectionManager({
            getAllNodes: this.nodeToNode.getAllConnectionNodeIds,
            hasSharedStreamParts: this.streamPartManager.isNodePresent.bind(this.streamPartManager),
            disconnect: this.nodeToNode.disconnectFromNode.bind(this.nodeToNode),
            disconnectionDelayInMs: (_a = opts.disconnectionWaitTime) !== null && _a !== void 0 ? _a : 30 * 1000,
            cleanUpIntervalInMs: 2 * 60 * 1000
        });
        this.propagation = new Propagation_1.Propagation({
            getNeighbors: this.streamPartManager.getOutboundNodesForStreamPart.bind(this.streamPartManager),
            sendToNeighbor: async (neighborId, streamMessage) => {
                try {
                    await this.nodeToNode.sendData(neighborId, streamMessage);
                    this.consecutiveDeliveryFailures[neighborId] = 0;
                }
                catch (e) {
                    const serializedMsgId = streamMessage.getMessageID().serialize();
                    logger.warn('failed to propagate %s (consecutiveFails=%d) to subscriber %s, reason: %s', serializedMsgId, this.consecutiveDeliveryFailures[neighborId] || 0, neighborId, e);
                    // TODO: this is hack to get around the issue where `StreamStateManager` believes that we are
                    //  connected to a neighbor whilst `WebRtcEndpoint` knows that we are not. In this situation, the
                    //  Node will continuously attempt to propagate messages to the neighbor but will not actually ever
                    //  (re-)attempt a connection unless as a side-effect of something else (e.g. subscribing to another
                    //  stream, and the neighbor in question happens to get assigned to us via the other stream.)
                    //
                    // This hack basically counts consecutive delivery failures, and upon hitting 100 such failures,
                    // decides to forcefully disconnect the neighbor.
                    //
                    // Ideally this hack would not be needed, but alas, it seems like with the current event-system,
                    // we don't end up with an up-to-date state in the logic layer. I believe something like the
                    // ConnectionManager-model could help us solve the issue for good.
                    if (this.consecutiveDeliveryFailures[neighborId] === undefined) {
                        this.consecutiveDeliveryFailures[neighborId] = 0;
                    }
                    this.consecutiveDeliveryFailures[neighborId] += 1;
                    if (this.consecutiveDeliveryFailures[neighborId] >= 100) {
                        logger.warn(`disconnecting from ${neighborId} due to 100 consecutive delivery failures`);
                        this.onNodeDisconnected(neighborId); // force disconnect
                        this.consecutiveDeliveryFailures[neighborId] = 0;
                    }
                }
            },
            minPropagationTargets: Math.floor(config_1.DEFAULT_MAX_NEIGHBOR_COUNT / 2)
        });
        this.trackerManager = new TrackerManager_1.TrackerManager(opts.protocols.nodeToTracker, opts, this.streamPartManager, this.metrics, (includeRtt) => ({
            started: this.started,
            location: this.peerInfo.location,
            extra: this.extraMetadata,
            rtts: includeRtt ? this.nodeToNode.getRtts() : null,
            version: "brubeck-1.0"
        }), {
            subscribeToStreamPartIfHaveNotYet: this.subscribeToStreamIfHaveNotYet.bind(this),
            subscribeToStreamPartOnNodes: this.subscribeToStreamPartOnNodes.bind(this),
            unsubscribeFromStreamPartOnNode: this.unsubscribeFromStreamPartOnNode.bind(this)
        });
        this.proxyStreamConnectionManager = new ProxyStreamConnectionManager_1.ProxyStreamConnectionManager({
            trackerManager: this.trackerManager,
            streamPartManager: this.streamPartManager,
            node: this,
            nodeToNode: this.nodeToNode,
            acceptProxyConnections: this.acceptProxyConnections,
            nodeConnectTimeout: this.nodeConnectTimeout
        });
        this.nodeToNode.on(NodeToNode_1.Event.NODE_CONNECTED, (nodeId) => this.emit(Event.NODE_CONNECTED, nodeId));
        this.nodeToNode.on(NodeToNode_1.Event.DATA_RECEIVED, (broadcastMessage, nodeId) => this.onDataReceived(broadcastMessage.streamMessage, nodeId));
        this.nodeToNode.on(NodeToNode_1.Event.NODE_DISCONNECTED, (nodeId) => this.onNodeDisconnected(nodeId));
        this.nodeToNode.on(NodeToNode_1.Event.PUBLISH_STREAM_REQUEST_RECEIVED, (message, nodeId) => {
            this.proxyStreamConnectionManager.processPublishStreamRequest(message, nodeId);
        });
        this.nodeToNode.on(NodeToNode_1.Event.PUBLISH_STREAM_RESPONSE_RECEIVED, (message, nodeId) => {
            this.proxyStreamConnectionManager.processPublishStreamResponse(message, nodeId);
        });
        this.nodeToNode.on(NodeToNode_1.Event.LEAVE_REQUEST_RECEIVED, (message, nodeId) => {
            this.proxyStreamConnectionManager.processLeaveRequest(message, nodeId);
        });
        let avgLatency = -1;
        this.on(Event.UNSEEN_MESSAGE_RECEIVED, (message) => {
            const now = new Date().getTime();
            const currentLatency = now - message.messageId.timestamp;
            if (avgLatency < 0) {
                avgLatency = currentLatency;
            }
            else {
                avgLatency = 0.8 * avgLatency + 0.2 * currentLatency;
            }
            this.metrics.set('latency', avgLatency);
        });
    }
    start() {
        logger.trace('started');
        this.trackerManager.start();
    }
    subscribeToStreamIfHaveNotYet(streamPartId, sendStatus = true) {
        if (!this.streamPartManager.isSetUp(streamPartId)) {
            logger.trace('add %s to streams', streamPartId);
            this.streamPartManager.setUpStreamPart(streamPartId);
            this.trackerManager.onNewStreamPart(streamPartId); // TODO: perhaps we should react based on event from StreamManager?
            if (sendStatus) {
                this.trackerManager.sendStreamPartStatus(streamPartId);
            }
        }
        else if (this.streamPartManager.isSetUp(streamPartId) && this.streamPartManager.isBehindProxy(streamPartId)) {
            logger.trace(`Could not join stream ${streamPartId} as stream is set to be behind proxy`);
        }
    }
    unsubscribeFromStream(streamPartId, sendStatus = true) {
        logger.trace('remove %s from streams', streamPartId);
        this.streamPartManager.removeStreamPart(streamPartId);
        this.trackerManager.onUnsubscribeFromStreamPart(streamPartId);
        if (sendStatus) {
            this.trackerManager.sendStreamPartStatus(streamPartId);
        }
    }
    subscribeToStreamPartOnNodes(nodeIds, streamPartId, trackerId, reattempt) {
        const subscribePromises = nodeIds.map(async (nodeId) => {
            await (0, PromiseTools_1.promiseTimeout)(this.nodeConnectTimeout, this.nodeToNode.connectToNode(nodeId, trackerId, !reattempt));
            this.disconnectionManager.cancelScheduledDisconnection(nodeId);
            this.subscribeToStreamPartOnNode(nodeId, streamPartId, false);
            return nodeId;
        });
        return Promise.allSettled(subscribePromises);
    }
    async openOutgoingStreamConnection(streamPartId, contactNodeId) {
        await this.proxyStreamConnectionManager.openOutgoingStreamConnection(streamPartId, contactNodeId);
    }
    closeOutgoingStreamConnection(streamPartId, contactNodeId) {
        this.proxyStreamConnectionManager.closeOutgoingStreamConnection(streamPartId, contactNodeId);
    }
    // Null source is used when a message is published by the node itself
    onDataReceived(streamMessage, source = null) {
        this.metrics.record('onDataReceived', 1);
        const streamPartId = streamMessage.getStreamPartID();
        // Check if the stream is set as one-directional and has inbound connection
        if (source
            && this.streamPartManager.isSetUp(streamPartId)
            && this.streamPartManager.isBehindProxy(streamPartId)
            && !this.streamPartManager.hasInboundConnection(streamPartId, source)) {
            logger.warn(`Unexpected message received on outgoing proxy stream from node ${source} on stream ${streamPartId}`);
            // Perhaps the node should be disconnected here if bad behaviour is repeated
            return;
        }
        this.emit(Event.MESSAGE_RECEIVED, streamMessage, source);
        this.subscribeToStreamIfHaveNotYet(streamPartId);
        // Check duplicate
        let isUnseen;
        try {
            isUnseen = this.streamPartManager.markNumbersAndCheckThatIsNotDuplicate(streamMessage.messageId, streamMessage.prevMsgRef);
        }
        catch (e) {
            if (e instanceof DuplicateMessageDetector_1.InvalidNumberingError) {
                logger.trace('received from %s data %j with invalid numbering', source, streamMessage.messageId);
                this.metrics.record('onDataReceived:invalidNumber', 1);
                return;
            }
            if (e instanceof DuplicateMessageDetector_1.GapMisMatchError) {
                logger.warn('received from %s data %j with gap mismatch detected: %j', source, streamMessage.messageId, e);
                this.metrics.record('onDataReceived:gapMismatch', 1);
                return;
            }
            throw e;
        }
        if (isUnseen) {
            logger.trace('received from %s data %j', source, streamMessage.messageId);
            this.emit(Event.UNSEEN_MESSAGE_RECEIVED, streamMessage, source);
            this.propagation.feedUnseenMessage(streamMessage, source);
        }
        else {
            logger.trace('ignoring duplicate data %j (from %s)', streamMessage.messageId, source);
            this.metrics.record('onDataReceived:ignoredDuplicate', 1);
        }
    }
    stop() {
        this.proxyStreamConnectionManager.stop();
        this.disconnectionManager.stop();
        this.nodeToNode.stop();
        return this.trackerManager.stop();
    }
    subscribeToStreamPartOnNode(node, streamPartId, sendStatus = true) {
        this.streamPartManager.addNeighbor(streamPartId, node);
        this.propagation.onNeighborJoined(node, streamPartId);
        if (sendStatus) {
            this.trackerManager.sendStreamPartStatus(streamPartId);
        }
        this.emit(Event.NODE_SUBSCRIBED, node, streamPartId);
        return node;
    }
    unsubscribeFromStreamPartOnNode(node, streamPartId, sendStatus = true) {
        this.streamPartManager.removeNodeFromStreamPart(streamPartId, node);
        logger.trace('node %s unsubscribed from stream %s', node, streamPartId);
        this.emit(Event.NODE_UNSUBSCRIBED, node, streamPartId);
        this.disconnectionManager.scheduleDisconnectionIfNoSharedStreamParts(node);
        if (sendStatus) {
            this.trackerManager.sendStreamPartStatus(streamPartId);
        }
    }
    onNodeDisconnected(node) {
        this.metrics.record('onNodeDisconnect', 1);
        const [streams, proxiedStreams] = this.streamPartManager.removeNodeFromAllStreamParts(node);
        logger.trace('removed all subscriptions of node %s', node);
        streams.forEach((s) => {
            this.trackerManager.sendStreamPartStatus(s);
        });
        proxiedStreams.forEach((s) => {
            this.proxyStreamConnectionManager.reconnect(node, s);
        });
        this.emit(Event.NODE_DISCONNECTED, node);
    }
    getStreamParts() {
        return this.streamPartManager.getStreamParts();
    }
    getNeighbors() {
        return this.streamPartManager.getAllNodes();
    }
    getNodeId() {
        return this.peerInfo.peerId;
    }
    getMetricsContext() {
        return this.metricsContext;
    }
}
exports.Node = Node;
//# sourceMappingURL=Node.js.map