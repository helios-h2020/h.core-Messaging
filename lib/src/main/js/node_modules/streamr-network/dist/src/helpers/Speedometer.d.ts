/**
 * Utility to analyze some throughput rate.
 *
 * Call record(value) to provide the input to the utility. The value parameter tells how many units
 * of some data have just been processed. It is not a cumulative value, but a count of the most
 * recently processed units.
 *
 * E.g. if you send a total of 1000 messages, you could call record(1) after each message. Or you could
 * call record(msg.getSizeInBytes()) after each message to provide the data for a bytes per second
 * throughput rate.
 *
 * At any time you can call getRate() to get the current throughput rate per second.
 *
 * The utility uses n second window to store the recorded data. If less than n seconds have been elapsed
 * from the construction of the utility, the shorter window is used temporarily.
 *
 * Internally the window is divided into one-second slots, each containing one UTC second of data. There are
 * windowSize + 1 slots: the first slot contains data for the current UTC second, and the last slot
 * contains data that has already partially expired. E.g. if 0.1 seconds has elapsed from a start of a UTC second,
 * the first slot can contain maximum 0.1 seconds of recorded data (as there can't be data for any future
 * timestamps). In that situation, we include 90% of the value from oldest slot to complement the
 * partial first slot.
 */
export declare class Speedometer {
    private static WINDOW_SIZE_DEFAULT;
    private secValues;
    private firstSecStartTime;
    private readonly startupTime;
    private readonly windowSizeInSeconds;
    private readonly currentTimeProvider;
    constructor(windowSizeInSeconds?: number, currentTimeProvider?: () => number);
    record(value: number): void;
    getRate(): number;
    private update;
}
