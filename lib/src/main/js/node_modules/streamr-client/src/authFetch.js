"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authRequest = exports.NotFoundError = exports.ValidationError = exports.AuthFetchError = exports.DEFAULT_HEADERS = exports.ErrorCode = void 0;
/**
 * Wrap fetch with default headers performing authentication if required.
 */
const node_fetch_1 = __importDefault(require("node-fetch"));
const log_1 = require("./utils/log");
const utils_1 = require("./utils");
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["NOT_FOUND"] = "NOT_FOUND";
    ErrorCode["VALIDATION_ERROR"] = "VALIDATION_ERROR";
    ErrorCode["UNKNOWN"] = "UNKNOWN";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
exports.DEFAULT_HEADERS = {
    'Streamr-Client': `streamr-client-javascript/${(0, utils_1.getVersionString)()}`,
};
class AuthFetchError extends Error {
    constructor(message, response, body, errorCode) {
        const typePrefix = errorCode ? errorCode + ': ' : '';
        // add leading space if there is a body set
        const bodyMessage = body ? ` ${(0, log_1.inspect)(body)}` : '';
        super(typePrefix + message + bodyMessage);
        this.response = response;
        this.body = body;
        this.code = errorCode || ErrorCode.UNKNOWN;
        this.errorCode = this.code;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.AuthFetchError = AuthFetchError;
class ValidationError extends AuthFetchError {
    constructor(message, response, body) {
        super(message, response, body, ErrorCode.VALIDATION_ERROR);
    }
}
exports.ValidationError = ValidationError;
class NotFoundError extends AuthFetchError {
    constructor(message, response, body) {
        super(message, response, body, ErrorCode.NOT_FOUND);
    }
}
exports.NotFoundError = NotFoundError;
const ERROR_TYPES = new Map();
ERROR_TYPES.set(ErrorCode.VALIDATION_ERROR, ValidationError);
ERROR_TYPES.set(ErrorCode.NOT_FOUND, NotFoundError);
ERROR_TYPES.set(ErrorCode.UNKNOWN, AuthFetchError);
const parseErrorCode = (body) => {
    let json;
    try {
        json = JSON.parse(body);
    }
    catch (err) {
        return ErrorCode.UNKNOWN;
    }
    const { code } = json;
    return code in ErrorCode ? code : ErrorCode.UNKNOWN;
};
async function authRequest(url, opts, requireNewToken = false, debug, fetchFn = node_fetch_1.default) {
    if (!debug) {
        const id = (0, utils_1.counterId)('authResponse');
        debug = (0, log_1.Debug)('utils').extend(id); // eslint-disable-line no-param-reassign
    }
    const timeStart = Date.now();
    const options = {
        ...opts,
        headers: {
            ...exports.DEFAULT_HEADERS,
            ...(opts && opts.headers),
        },
    };
    // add default 'Content-Type: application/json' header for all POST and PUT requests
    if (!options.headers['Content-Type'] && (options.method === 'POST' || options.method === 'PUT')) {
        options.headers['Content-Type'] = 'application/json';
    }
    debug('%s >> %o', url, opts);
    const response = await fetchFn(url, {
        ...opts,
        headers: {
            ...((opts === null || opts === void 0 ? void 0 : opts.session) && !opts.session.isUnauthenticated() ? {
                Authorization: `Bearer ${await opts.session.getSessionToken(requireNewToken)}`,
            } : {}),
            ...options.headers,
        },
    });
    const timeEnd = Date.now();
    debug('%s << %d %s %s %s', url, response.status, response.statusText, log_1.Debug.humanize(timeEnd - timeStart));
    if (response.ok) {
        return response;
    }
    if ([400, 401].includes(response.status) && !requireNewToken) {
        debug('%d %s – revalidating session');
        return authRequest(url, options, true);
    }
    debug('%s – failed', url);
    const body = await response.text();
    const errorCode = parseErrorCode(body);
    const ErrorClass = ERROR_TYPES.get(errorCode);
    throw new ErrorClass(`Request ${debug.namespace} to ${url} returned with error code ${response.status}.`, response, body, errorCode);
}
exports.authRequest = authRequest;
/** @internal */
async function authFetch(url, opts, requireNewToken = false, debug, fetchFn) {
    const id = (0, utils_1.counterId)('authFetch');
    debug = debug || (0, log_1.Debug)('utils').extend(id); // eslint-disable-line no-param-reassign
    const response = await authRequest(url, opts, requireNewToken, debug, fetchFn);
    // can only be ok response
    const body = await response.text();
    try {
        return JSON.parse(body || '{}');
    }
    catch (e) {
        debug('%s – failed to parse body: %s', url, e.stack);
        throw new AuthFetchError(e.message, response, body);
    }
}
exports.default = authFetch;
//# sourceMappingURL=authFetch.js.map