"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublisherKeyExchange = void 0;
const streamr_client_protocol_1 = require("streamr-client-protocol");
const tsyringe_1 = require("tsyringe");
const utils_1 = require("../utils");
const Publisher_1 = __importDefault(require("../publish/Publisher"));
const GroupKeyStoreFactory_1 = __importDefault(require("./GroupKeyStoreFactory"));
const Encryption_1 = __importDefault(require("./Encryption"));
const KeyExchangeUtils_1 = require("./KeyExchangeUtils");
const StreamEndpointsCached_1 = require("../StreamEndpointsCached");
class InvalidGroupKeyRequestError extends streamr_client_protocol_1.ValidationError {
    constructor(msg) {
        super(msg, 'INVALID_GROUP_KEY_REQUEST');
    }
}
let PublisherKeyExchange = class PublisherKeyExchange {
    constructor(publisher, groupKeyStoreFactory, streamEndpoints, keyExchangeStream) {
        this.publisher = publisher;
        this.groupKeyStoreFactory = groupKeyStoreFactory;
        this.streamEndpoints = streamEndpoints;
        this.keyExchangeStream = keyExchangeStream;
        this.enabled = true;
        this.id = (0, utils_1.instanceId)(this);
        this.debug = this.publisher.debug.extend(this.id);
        const getSubscription = (0, utils_1.pOnce)(this.subscribe.bind(this));
        this.getSubscription = getSubscription;
        this.onKeyExchangeMessage = this.onKeyExchangeMessage.bind(this);
    }
    getWrapError(streamMessage) {
        return async (error) => {
            var _a;
            try {
                const subscriberId = streamMessage.getPublisherId();
                if (!streamr_client_protocol_1.GroupKeyRequest.is(streamMessage)) {
                    // ignore weird message
                    return undefined;
                }
                const msg = streamMessage.getParsedContent();
                const { streamId, requestId, groupKeyIds } = streamr_client_protocol_1.GroupKeyRequest.fromArray(msg);
                const response = new streamr_client_protocol_1.GroupKeyErrorResponse({
                    requestId,
                    streamId,
                    errorCode: (_a = error.code) !== null && _a !== void 0 ? _a : 'UNEXPECTED_ERROR',
                    errorMessage: error.message,
                    groupKeyIds
                });
                return await this.keyExchangeStream.response(subscriberId, response);
            }
            catch (err) {
                this.debug('unexpected error responding with error', err);
                return undefined;
            }
        };
    }
    async onKeyExchangeMessage(streamMessage) {
        if (!streamMessage) {
            return;
        }
        const wrapError = this.getWrapError(streamMessage);
        try {
            if (!streamr_client_protocol_1.GroupKeyRequest.is(streamMessage)) {
                return;
            }
            // No need to check if parsedContent contains the necessary fields because it was already checked during deserialization
            const { requestId, streamId, rsaPublicKey, groupKeyIds } = streamr_client_protocol_1.GroupKeyRequest.fromArray(streamMessage.getParsedContent());
            const subscriberId = streamMessage.getPublisherId();
            const isSubscriber = await this.streamEndpoints.isStreamSubscriber(streamId, subscriberId);
            const groupKeyStore = await this.groupKeyStoreFactory.getStore(streamId);
            const encryptedGroupKeys = (!isSubscriber ? [] : await Promise.all(groupKeyIds.map(async (id) => {
                const groupKey = await groupKeyStore.get(id);
                if (!groupKey) {
                    return null; // will be filtered out
                }
                const key = Encryption_1.default.encryptWithPublicKey(groupKey.data, rsaPublicKey, true);
                return new streamr_client_protocol_1.EncryptedGroupKey(id, key);
            }))).filter(Boolean);
            this.debug('Subscriber requested groupKeys: %d. Got: %d. %o', groupKeyIds.length, encryptedGroupKeys.length, {
                subscriberId,
                groupKeyIds,
                responseKeys: encryptedGroupKeys.map(({ groupKeyId }) => groupKeyId),
            });
            const response = new streamr_client_protocol_1.GroupKeyResponse({
                streamId,
                requestId,
                encryptedGroupKeys,
            });
            await this.keyExchangeStream.response(subscriberId, response);
        }
        catch (err) {
            if (!('streamMessage' in err)) {
                this.debug('unexpected', err);
                return; // do nothing, supress.
            }
            await wrapError(err);
        }
    }
    async subscribe() {
        if (!this.enabled) {
            return undefined;
        }
        const sub = await this.keyExchangeStream.subscribe();
        if (!sub) {
            return undefined;
        }
        if (!this.enabled) {
            await sub.unsubscribe();
            return undefined;
        }
        sub.consume(this.onKeyExchangeMessage).catch(() => { });
        sub.onError(async (err) => {
            if (!('streamMessage' in err)) {
                this.debug('unexpected', err);
                return; // do nothing, supress.
            }
            // eslint-disable-next-line promise/no-promise-in-callback
            await this.getWrapError(err.streamMessage)(new InvalidGroupKeyRequestError(err.message)).catch((error) => {
                this.debug('unexpected error sending error', error);
            });
        });
        return sub;
    }
    async getGroupKeyStore(streamId) {
        return this.groupKeyStoreFactory.getStore(streamId);
    }
    async rotateGroupKey(streamId) {
        if (!this.enabled) {
            return;
        }
        try {
            const groupKeyStore = await this.getGroupKeyStore(streamId);
            await groupKeyStore.rotateGroupKey();
        }
        finally {
            this.streamEndpoints.clearStream(streamId);
        }
    }
    async setNextGroupKey(streamId, groupKey) {
        if (!this.enabled) {
            return;
        }
        try {
            const groupKeyStore = await this.getGroupKeyStore(streamId);
            if (!this.enabled) {
                return;
            }
            await groupKeyStore.setNextGroupKey(groupKey);
        }
        finally {
            this.streamEndpoints.clearStream(streamId);
        }
    }
    async useGroupKey(streamId) {
        await this.getSubscription();
        if (!this.enabled) {
            return [];
        }
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        if (!this.enabled) {
            return [];
        }
        return groupKeyStore.useGroupKey();
    }
    async hasAnyGroupKey(streamId) {
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        if (!this.enabled) {
            return false;
        }
        return !(await groupKeyStore.isEmpty());
    }
    async rekey(streamId) {
        try {
            if (!this.enabled) {
                return;
            }
            const groupKeyStore = await this.getGroupKeyStore(streamId);
            if (!this.enabled) {
                return;
            }
            await groupKeyStore.rekey();
            if (!this.enabled) {
                return;
            }
            await this.getSubscription();
        }
        finally {
            this.streamEndpoints.clearStream(streamId);
        }
    }
    async start() {
        this.enabled = true;
        await this.subscribe();
    }
    async stop() {
        this.enabled = false;
        this.getSubscription.reset();
        await this.subscribe();
    }
};
PublisherKeyExchange = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => Publisher_1.default))),
    __param(3, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => KeyExchangeUtils_1.KeyExchangeStream))),
    __metadata("design:paramtypes", [Publisher_1.default,
        GroupKeyStoreFactory_1.default,
        StreamEndpointsCached_1.StreamEndpointsCached,
        KeyExchangeUtils_1.KeyExchangeStream])
], PublisherKeyExchange);
exports.PublisherKeyExchange = PublisherKeyExchange;
//# sourceMappingURL=KeyExchangePublisher.js.map