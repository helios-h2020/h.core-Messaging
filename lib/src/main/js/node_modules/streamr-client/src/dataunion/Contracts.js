"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const address_1 = require("@ethersproject/address");
const bytes_1 = require("@ethersproject/bytes");
const contracts_1 = require("@ethersproject/contracts");
const wallet_1 = require("@ethersproject/wallet");
const log_1 = require("../utils/log");
const abi_1 = require("./abi");
const bignumber_1 = require("@ethersproject/bignumber");
const log = (0, log_1.Debug)('Contracts');
function validateAddress(name, address) {
    if (!(0, address_1.isAddress)(address)) {
        throw new Error(`${name} is ${address ? 'not a valid Ethereum address' : 'missing'}`);
    }
}
class Contracts {
    constructor(client) {
        this.ethereum = client.ethereum;
        this.factoryMainnetAddress = client.options.dataUnion.factoryMainnetAddress;
        this.factorySidechainAddress = client.options.dataUnion.factorySidechainAddress;
        this.templateMainnetAddress = client.options.dataUnion.templateMainnetAddress;
        this.templateSidechainAddress = client.options.dataUnion.templateSidechainAddress;
        this.binanceAdapterAddress = client.options.binanceAdapterAddress;
        this.binanceSmartChainAMBAddress = client.options.binanceSmartChainAMBAddress;
    }
    /**
     * Check if there is a data union in given address, return its version
     * @returns 0 if target address is not a Data Union contract
     */
    async getVersion(contractAddress) {
        validateAddress('contractAddress', contractAddress);
        const provider = this.ethereum.getMainnetProvider();
        const du = new contracts_1.Contract(contractAddress, [{
                name: 'version',
                inputs: [],
                outputs: [{ type: 'uint256' }],
                stateMutability: 'view',
                type: 'function'
            }], provider);
        try {
            const version = await du.version();
            return version.toNumber();
        }
        catch (e) {
            // "not a data union"
            return 0;
        }
    }
    async getMainnetContractReadOnly(contractAddress) {
        const version = await this.getVersion(contractAddress);
        if (version === 0) {
            throw new Error(`${contractAddress} is not a Data Union contract`);
        }
        const provider = this.ethereum.getMainnetProvider();
        return new contracts_1.Contract(contractAddress, abi_1.dataUnionMainnetABI, provider);
    }
    async getMainnetContract(contractAddress) {
        const du = await this.getMainnetContractReadOnly(contractAddress);
        const signer = this.ethereum.getSigner();
        return du.connect(signer);
    }
    async getSidechainContract(contractAddress) {
        const signer = await this.ethereum.getDataUnionChainSigner();
        const duMainnet = await this.getMainnetContractReadOnly(contractAddress);
        const duSidechainAddress = await duMainnet.sidechainAddress();
        const duSidechain = new contracts_1.Contract(duSidechainAddress, abi_1.dataUnionSidechainABI, signer);
        return duSidechain;
    }
    async getSidechainContractReadOnly(contractAddress) {
        const provider = this.ethereum.getDataUnionChainProvider();
        const duMainnet = await this.getMainnetContractReadOnly(contractAddress);
        const duSidechainAddress = await duMainnet.sidechainAddress();
        const duSidechain = new contracts_1.Contract(duSidechainAddress, abi_1.dataUnionSidechainABI, provider);
        return duSidechain;
    }
    // Find the Asyncronous Message-passing Bridge sidechain ("home") contract
    async getSidechainAmb() {
        if (!this.cachedSidechainAmb) {
            const getAmbPromise = async () => {
                const sidechainProvider = this.ethereum.getDataUnionChainProvider();
                const factorySidechain = new contracts_1.Contract(this.factorySidechainAddress, [{
                        name: 'amb',
                        inputs: [],
                        outputs: [{ type: 'address' }],
                        stateMutability: 'view',
                        type: 'function'
                    }], sidechainProvider);
                const sidechainAmbAddress = await factorySidechain.amb();
                return new contracts_1.Contract(sidechainAmbAddress, abi_1.sidechainAmbABI, sidechainProvider);
            };
            this.cachedSidechainAmb = getAmbPromise();
            this.cachedSidechainAmb = await this.cachedSidechainAmb; // eslint-disable-line require-atomic-updates
        }
        return this.cachedSidechainAmb;
    }
    async getMainnetAmb() {
        const mainnetProvider = this.ethereum.getMainnetProvider();
        const factoryMainnet = new contracts_1.Contract(this.factoryMainnetAddress, abi_1.factoryMainnetABI, mainnetProvider);
        const mainnetAmbAddress = await factoryMainnet.amb();
        return new contracts_1.Contract(mainnetAmbAddress, abi_1.mainnetAmbABI, mainnetProvider);
    }
    async getBinanceAdapter() {
        return new contracts_1.Contract(this.binanceAdapterAddress, abi_1.binanceAdapterABI, await this.ethereum.getDataUnionChainSigner());
    }
    getBinanceAdapterReadOnly() {
        return new contracts_1.Contract(this.binanceAdapterAddress, abi_1.binanceAdapterABI, this.ethereum.getDataUnionChainProvider());
    }
    async getBinanceSmartChainAmb(binanceSenderPrivateKey) {
        const signer = new wallet_1.Wallet(binanceSenderPrivateKey, this.ethereum.getBinanceProvider());
        return new contracts_1.Contract(this.binanceSmartChainAMBAddress, abi_1.mainnetAmbABI, signer);
    }
    async requiredSignaturesHaveBeenCollected(messageHash) {
        const sidechainAmb = await this.getSidechainAmb();
        const requiredSignatureCount = await sidechainAmb.requiredSignatures();
        // Bit 255 is set to mark completion, double check though
        const sigCountStruct = await sidechainAmb.numMessagesSigned(messageHash);
        const collectedSignatureCount = sigCountStruct.mask(255);
        const markedComplete = sigCountStruct.shr(255).gt(0);
        log(`${collectedSignatureCount.toString()} out of ${requiredSignatureCount.toString()} collected`);
        if (markedComplete) {
            log('All signatures collected');
        }
        return markedComplete;
    }
    /**
     * Move signatures from sidechain to mainnet
     * @returns null if message was already transported, ELSE the mainnet AMB signature execution transaction receipt
     */
    async transportSignaturesForMessage(messageHash, ethersOptions = {}) {
        const sidechainAmb = await this.getSidechainAmb();
        const message = await sidechainAmb.message(messageHash);
        const messageId = '0x' + message.substr(2, 64);
        const sigCountStruct = await sidechainAmb.numMessagesSigned(messageHash);
        const collectedSignatureCount = sigCountStruct.mask(255).toNumber();
        log(`${collectedSignatureCount} signatures reported, getting them from the sidechain AMB...`);
        const signatures = await Promise.all(Array(collectedSignatureCount).fill(0).map(async (_, i) => sidechainAmb.signature(messageHash, i)));
        const [vArray, rArray, sArray] = [[], [], []];
        signatures.forEach((signature, i) => {
            log(`  Signature ${i}: ${signature} (len=${signature.length} = ${signature.length / 2 - 1} bytes)`);
            rArray.push(signature.substr(2, 64));
            sArray.push(signature.substr(66, 64));
            vArray.push(signature.substr(130, 2));
        });
        const packedSignatures = bignumber_1.BigNumber.from(signatures.length).toHexString() + vArray.join('') + rArray.join('') + sArray.join('');
        log(`All signatures packed into one: ${packedSignatures}`);
        // Gas estimation also checks that the transaction would succeed, and provides a helpful error message in case it would fail
        const mainnetAmb = await this.getMainnetAmb();
        log(`Estimating gas using mainnet AMB @ ${mainnetAmb.address}, message=${message}`);
        let gasLimit;
        try {
            // magic number suggested by https://github.com/poanetwork/tokenbridge/blob/master/oracle/src/utils/constants.js
            gasLimit = bignumber_1.BigNumber.from(await mainnetAmb.estimateGas.executeSignatures(message, packedSignatures)).add(200000);
            log(`Calculated gas limit: ${gasLimit.toString()}`);
        }
        catch (e) {
            // Failure modes from https://github.com/poanetwork/tokenbridge/blob/master/oracle/src/events/processAMBCollectedSignatures/estimateGas.js
            log('Gas estimation failed: Check if the message was already processed');
            const alreadyProcessed = await mainnetAmb.relayedMessages(messageId);
            if (alreadyProcessed) {
                log(`WARNING: Tried to transport signatures but they have already been transported (Message ${messageId} has already been processed)`);
                log('This could happen if bridge paid for transport before your client.');
                return null;
            }
            log('Gas estimation failed: Check if number of signatures is enough');
            const mainnetProvider = this.ethereum.getMainnetProvider();
            const validatorContractAddress = await mainnetAmb.validatorContract();
            const validatorContract = new contracts_1.Contract(validatorContractAddress, [{
                    name: 'isValidator',
                    inputs: [{ type: 'address' }],
                    outputs: [{ type: 'bool' }],
                    stateMutability: 'view',
                    type: 'function'
                }, {
                    name: 'requiredSignatures',
                    inputs: [],
                    outputs: [{ type: 'uint256' }],
                    stateMutability: 'view',
                    type: 'function'
                }], mainnetProvider);
            const requiredSignatures = await validatorContract.requiredSignatures();
            if (requiredSignatures.gt(signatures.length)) {
                throw new Error('The number of required signatures does not match between sidechain('
                    + signatures.length + ' and mainnet( ' + requiredSignatures.toString());
            }
            log('Gas estimation failed: Check if all the signatures were made by validators');
            log(`  Recover signer addresses from signatures [${signatures.join(', ')}]`);
            const signers = signatures.map((signature) => (0, wallet_1.verifyMessage)((0, bytes_1.arrayify)(message), signature));
            log(`  Check that signers are validators [[${signers.join(', ')}]]`);
            const isValidatorArray = await Promise.all(signers.map((address) => [address, validatorContract.isValidator(address)]));
            const nonValidatorSigners = isValidatorArray.filter(([, isValidator]) => !isValidator);
            if (nonValidatorSigners.length > 0) {
                throw new Error(`Following signers are not listed as validators in mainnet validator contract at ${validatorContractAddress}:\n - `
                    + nonValidatorSigners.map(([address]) => address).join('\n - '));
            }
            throw new Error(`Gas estimation failed: Unknown error while processing message ${message} with ${e.stack}`);
        }
        const signer = this.ethereum.getSigner();
        log(`Sending message from signer=${await signer.getAddress()}`);
        const txAMB = await mainnetAmb.connect(signer).executeSignatures(message, packedSignatures, ethersOptions);
        const trAMB = await txAMB.wait();
        return trAMB;
    }
}
exports.default = Contracts;
//# sourceMappingURL=Contracts.js.map