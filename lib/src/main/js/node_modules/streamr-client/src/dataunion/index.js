"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tsyringe_1 = require("tsyringe");
const bignumber_1 = require("@ethersproject/bignumber");
const bytes_1 = require("@ethersproject/bytes");
const contracts_1 = require("@ethersproject/contracts");
const keccak256_1 = require("@ethersproject/keccak256");
const Ethereum_1 = __importDefault(require("../Ethereum"));
const Rest_1 = require("../Rest");
const Config_1 = require("../Config");
const DataUnion_1 = require("./DataUnion");
const address_1 = require("@ethersproject/address");
const Contracts_1 = __importDefault(require("./Contracts"));
const abi_1 = require("@ethersproject/abi");
const abi_2 = require("./abi");
const log_1 = require("../utils/log");
const units_1 = require("@ethersproject/units");
const utils_1 = require("../utils");
const log = (0, log_1.Debug)('DataUnionAPI');
const balanceOfAbi = [{
        name: 'balanceOf',
        inputs: [{ type: 'address' }],
        outputs: [{ type: 'uint256' }],
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function'
    }];
let DataUnionAPI = class DataUnionAPI {
    constructor(ethereum, rest, options) {
        this.ethereum = ethereum;
        this.rest = rest;
        this.options = options;
    }
    /**
     * Get token balance in "wei" (10^-18 parts) for given address
     */
    async getTokenBalance(address) {
        const { tokenAddress } = this.options;
        const addr = (0, address_1.getAddress)(address);
        const providers = this.ethereum.getAllMainnetProviders();
        const tokens = providers.map((provider) => {
            return new contracts_1.Contract(tokenAddress, balanceOfAbi, provider);
        });
        return Promise.any([
            ...tokens.map((token) => token.balanceOf(addr))
        ]);
    }
    /**
     * Get token balance in "wei" (10^-18 parts) for given address in sidechain
     */
    async getSidechainTokenBalance(address) {
        const { tokenSidechainAddress } = this.options;
        const addr = (0, address_1.getAddress)(address);
        const providers = this.ethereum.getAllDataUnionChainProviders();
        const tokens = providers.map((provider) => {
            return new contracts_1.Contract(tokenSidechainAddress, balanceOfAbi, provider);
        });
        return Promise.any([
            ...tokens.map((token) => token.balanceOf(addr))
        ]);
    }
    /**
     * NOTE: if template address is not given, calculation only works for the newest currently deployed factory,
     *       i.e. can be used for "future deployments" but NOT for old deployments
     * For old deployments, please use getDataUnion
     */
    async calculateDataUnionAddresses(dataUnionName, deployerAddress) {
        const deployer = deployerAddress !== null && deployerAddress !== void 0 ? deployerAddress : await this.ethereum.getAddress();
        const { templateMainnetAddress, templateSidechainAddress, factoryMainnetAddress, factorySidechainAddress, } = this.options.dataUnion;
        // The magic hex strings come from https://github.com/streamr-dev/data-union-solidity/blob/master/contracts/CloneLib.sol#L19
        const salt = (0, keccak256_1.keccak256)(abi_1.defaultAbiCoder.encode(['string', 'address'], [dataUnionName, deployer]));
        const codeHashM = (0, keccak256_1.keccak256)(`0x3d602d80600a3d3981f3363d3d373d3d3d363d73${templateMainnetAddress.slice(2)}5af43d82803e903d91602b57fd5bf3`);
        const mainnetAddress = (0, address_1.getCreate2Address)(factoryMainnetAddress, salt, codeHashM);
        const codeHashS = (0, keccak256_1.keccak256)(`0x3d602d80600a3d3981f3363d3d373d3d3d363d73${templateSidechainAddress.slice(2)}5af43d82803e903d91602b57fd5bf3`);
        const sidechainAddress = (0, address_1.getCreate2Address)(factorySidechainAddress, (0, bytes_1.hexZeroPad)(mainnetAddress, 32), codeHashS);
        return { mainnetAddress, sidechainAddress };
    }
    async getDataUnion(contractAddress) {
        if (!(0, address_1.isAddress)(contractAddress)) {
            throw new Error(`Can't get Data Union, invalid Ethereum address: ${contractAddress}`);
        }
        const version = await DataUnion_1.DataUnion.getVersion(contractAddress, this);
        if (version === 0) {
            throw new Error(`${contractAddress} is not a Data Union!`);
        }
        else if (version === 1) {
            throw new Error(`${contractAddress} is an old Data Union, please use StreamrClient 4.x or earlier!`);
        }
        else if (version === 2) {
            const contracts = new Contracts_1.default(this);
            const sidechainContract = await contracts.getSidechainContractReadOnly(contractAddress);
            return new DataUnion_1.DataUnion(contractAddress, sidechainContract.address, this);
        }
        throw new Error(`${contractAddress} is an unknown Data Union version "${version}"`);
    }
    /**
     * Create a new DataUnionMainnet contract to mainnet with DataUnionFactoryMainnet
     * This triggers DataUnionSidechain contract creation in sidechain, over the bridge (AMB)
     * @return Promise<DataUnion> that resolves when the new DU is deployed over the bridge to side-chain
     */
    async deployDataUnion(options = {}) {
        const deployerAddress = await this.ethereum.getAddress();
        const mainnetProvider = this.ethereum.getMainnetProvider();
        const mainnetWallet = this.ethereum.getSigner();
        const duChainProvider = this.ethereum.getDataUnionChainProvider();
        const { factoryMainnetAddress } = this.options.dataUnion;
        const { owner = deployerAddress, joinPartAgents = [owner, this.options.streamrNodeAddress], dataUnionName = `DataUnion-${Date.now()}`, // TODO: use uuid
        adminFee = 0, sidechainPollingIntervalMs = 1000, sidechainRetryTimeoutMs = 600000, confirmations = 1, gasPrice } = options;
        log(`Going to deploy Data Union with name: ${dataUnionName}`);
        if (adminFee < 0 || adminFee > 1) {
            throw new Error('options.adminFeeFraction must be a number between 0...1, got: ' + adminFee);
        }
        const adminFeeBN = bignumber_1.BigNumber.from((adminFee * 1e18).toFixed()); // last 2...3 decimals are going to be gibberish
        const ownerAddress = (0, address_1.getAddress)(owner);
        const agentAddressList = joinPartAgents.map(address_1.getAddress);
        const { mainnetAddress, sidechainAddress, } = await this.calculateDataUnionAddresses(dataUnionName, deployerAddress);
        if (await mainnetProvider.getCode(mainnetAddress) !== '0x') {
            throw new Error(`Mainnet data union "${dataUnionName}" contract ${mainnetAddress} already exists!`);
        }
        if (await mainnetProvider.getCode(factoryMainnetAddress) === '0x') {
            throw new Error(`Contract not found at ${factoryMainnetAddress}, check StreamrClient.options.dataUnion.factoryMainnetAddress!`);
        }
        const factoryMainnet = new contracts_1.Contract(factoryMainnetAddress, abi_2.factoryMainnetABI, mainnetWallet);
        const ethersOptions = {};
        if (gasPrice) {
            ethersOptions.gasPrice = gasPrice;
        }
        const duFeeFraction = (0, units_1.parseEther)('0'); // TODO: decide what the default values should be
        const duBeneficiary = '0x0000000000000000000000000000000000000000'; // TODO: decide what the default values should be
        const tx = await factoryMainnet.deployNewDataUnion(ownerAddress, adminFeeBN, duFeeFraction, duBeneficiary, agentAddressList, dataUnionName, ethersOptions);
        await tx.wait(confirmations);
        log(`Data Union deployed to mainnet: ${mainnetAddress}, waiting for sidechain: ${sidechainAddress}`);
        await (0, utils_1.until)(async () => await duChainProvider.getCode(sidechainAddress) !== '0x', sidechainRetryTimeoutMs, sidechainPollingIntervalMs);
        return new DataUnion_1.DataUnion(mainnetAddress, sidechainAddress, this);
    }
    async setBinanceDepositAddress(binanceRecipient) {
        return DataUnion_1.DataUnion._setBinanceDepositAddress(binanceRecipient, this); // eslint-disable-line no-underscore-dangle
    }
    async setBinanceDepositAddressFromSignature(from, binanceRecipient, signature) {
        return DataUnion_1.DataUnion._setBinanceDepositAddressFromSignature(from, binanceRecipient, signature, this); // eslint-disable-line no-underscore-dangle
    }
    // TODO: define returned object's type
    async setBinanceDepositAddressViaWithdrawServer(from, binanceRecipient, signature) {
        const body = {
            memberAddress: from,
            binanceRecipientAddress: binanceRecipient,
            signature
        };
        return this.rest.post(['binanceAdapterSetRecipient'], body, {
            restUrl: this.options.withdrawServerUrl,
        });
    }
    async getBinanceDepositAddress(userAddress) {
        return DataUnion_1.DataUnion._getBinanceDepositAddress(userAddress, this); // eslint-disable-line no-underscore-dangle
    }
    async signSetBinanceRecipient(recipientAddress) {
        const to = (0, address_1.getAddress)(recipientAddress); // throws if bad address
        const signer = this.ethereum.getSigner();
        return DataUnion_1.DataUnion._createSetBinanceRecipientSignature(to, signer, new Contracts_1.default(this)); // eslint-disable-line no-underscore-dangle
    }
};
DataUnionAPI = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(2, (0, tsyringe_1.inject)(Config_1.Config.Root)),
    __metadata("design:paramtypes", [Ethereum_1.default,
        Rest_1.Rest, Object])
], DataUnionAPI);
exports.default = DataUnionAPI;
//# sourceMappingURL=index.js.map