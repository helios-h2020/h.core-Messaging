"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var StreamRegistry_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamRegistry = void 0;
const contracts_1 = require("@ethersproject/contracts");
const StreamRegistryV3Abi_json_1 = __importDefault(require("./ethereumArtifacts/StreamRegistryV3Abi.json"));
const tsyringe_1 = require("tsyringe");
const Container_1 = require("./Container");
const Ethereum_1 = __importDefault(require("./Ethereum"));
const utils_1 = require("./utils");
const Context_1 = require("./utils/Context");
const Config_1 = require("./Config");
const Stream_1 = require("./Stream");
const authFetch_1 = require("./authFetch");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const StreamIDBuilder_1 = require("./StreamIDBuilder");
const lodash_1 = require("lodash");
const GraphQLClient_1 = require("./utils/GraphQLClient");
const searchStreams_1 = require("./searchStreams");
const GeneratorUtils_1 = require("./utils/GeneratorUtils");
const contract_1 = require("./utils/contract");
const permission_1 = require("./permission");
const StreamEndpointsCached_1 = require("./StreamEndpointsCached");
let StreamRegistry = StreamRegistry_1 = class StreamRegistry {
    constructor(context, ethereum, streamIdBuilder, container, config, graphQLClient, streamEndpointsCached) {
        this.ethereum = ethereum;
        this.streamIdBuilder = streamIdBuilder;
        this.container = container;
        this.config = config;
        this.graphQLClient = graphQLClient;
        this.streamEndpointsCached = streamEndpointsCached;
        this.id = (0, utils_1.instanceId)(this);
        this.debug = context.debug.extend(this.id);
        this.debug('create');
        this.chainProviders = this.ethereum.getAllStreamRegistryChainProviders();
        this.streamRegistryContractsReadonly = this.chainProviders.map((provider) => {
            return (0, contract_1.withErrorHandlingAndLogging)(new contracts_1.Contract(this.config.streamRegistryChainAddress, StreamRegistryV3Abi_json_1.default, provider), 'streamRegistry');
        });
    }
    parseStream(id, metadata) {
        const props = Stream_1.Stream.parsePropertiesFromMetadata(metadata);
        return new Stream_1.Stream({ ...props, id }, this.container);
    }
    // --------------------------------------------------------------------------------------------
    // Read from the StreamRegistry contract
    // --------------------------------------------------------------------------------------------
    async getStreamFromContract(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('getStream %s', streamId);
        try {
            const metadata = await this.queryAllReadonlyContracts((contract) => {
                return contract.getStreamMetadata(streamId) || '{}';
            });
            return this.parseStream(streamId, metadata);
        }
        catch (error) {
            this.debug(error);
        }
        throw new authFetch_1.NotFoundError('Stream: id=' + streamId);
    }
    // --------------------------------------------------------------------------------------------
    // Send transactions to the StreamRegistry contract
    // --------------------------------------------------------------------------------------------
    async connectToStreamRegistryContract() {
        if (!this.chainSigner || !this.streamRegistryContract) {
            this.chainSigner = await this.ethereum.getStreamRegistryChainSigner();
            this.streamRegistryContract = (0, contract_1.withErrorHandlingAndLogging)(new contracts_1.Contract(this.config.streamRegistryChainAddress, StreamRegistryV3Abi_json_1.default, this.chainSigner), 'streamRegistry');
        }
    }
    async createStream(propsOrStreamIdOrPath) {
        var _a;
        const props = typeof propsOrStreamIdOrPath === 'object' ? propsOrStreamIdOrPath : { id: propsOrStreamIdOrPath };
        (_a = props.partitions) !== null && _a !== void 0 ? _a : (props.partitions = 1);
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        const streamId = await this.streamIdBuilder.toStreamID(props.id);
        const metadata = StreamRegistry_1.formMetadata(props);
        const domainAndPath = streamr_client_protocol_1.StreamIDUtils.getDomainAndPath(streamId);
        if (domainAndPath === undefined) {
            throw new Error(`stream id "${streamId}" not valid`);
        }
        const [domain, path] = domainAndPath;
        await this.connectToStreamRegistryContract();
        if (streamr_client_protocol_1.StreamIDUtils.isENSAddress(domain)) {
            /*
                The call to createStreamWithENS delegates the ENS ownership check, and therefore the
                call doesn't fail e.g. if the user doesn't own the ENS name. To see whether the stream
                creation succeeeds, we need to poll the chain for stream existence. If the polling timeouts, we don't
                know what the actual error was. (Most likely it has nothing to do with timeout
                -> we don't use the error from until(), but throw an explicit error instead.)
            */
            await (0, contract_1.waitForTx)(this.streamRegistryContract.createStreamWithENS(domain, path, metadata, ethersOverrides));
            try {
                await (0, utils_1.until)(async () => this.streamExistsOnChain(streamId), 
                // eslint-disable-next-line no-underscore-dangle
                this.config._timeouts.jsonRpc.timeout, 
                // eslint-disable-next-line no-underscore-dangle
                this.config._timeouts.jsonRpc.retryInterval);
            }
            catch (e) {
                throw new Error(`unable to create stream "${streamId}"`);
            }
        }
        else {
            await this.ensureStreamIdInNamespaceOfAuthenticatedUser(domain, streamId);
            await (0, contract_1.waitForTx)(this.streamRegistryContract.createStream(path, metadata, ethersOverrides));
        }
        return new Stream_1.Stream({
            ...props,
            id: streamId
        }, this.container);
    }
    async ensureStreamIdInNamespaceOfAuthenticatedUser(address, streamId) {
        const userAddress = await this.ethereum.getAddress();
        if (address.toLowerCase() !== userAddress.toLowerCase()) {
            throw new Error(`stream id "${streamId}" not in namespace of authenticated user "${userAddress}"`);
        }
    }
    async updateStream(props) {
        const streamId = await this.streamIdBuilder.toStreamID(props.id);
        await this.connectToStreamRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.streamRegistryContract.updateStreamMetadata(streamId, StreamRegistry_1.formMetadata(props), ethersOverrides));
        return new Stream_1.Stream({
            ...props,
            id: streamId
        }, this.container);
    }
    async deleteStream(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('Deleting stream %s', streamId);
        await this.connectToStreamRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.streamRegistryContract.deleteStream(streamId, ethersOverrides));
    }
    async streamExistsOnChain(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('Checking if stream exists on chain %s', streamId);
        return Promise.any([
            ...this.streamRegistryContractsReadonly.map((contract) => {
                return contract.exists(streamId);
            })
        ]);
    }
    async streamExistsOnTheGraph(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('Checking if stream exists on theGraph %s', streamId);
        try {
            await this.getStreamFromGraph(streamId);
            return true;
        }
        catch (err) {
            if (err.errorCode === 'NOT_FOUND') {
                return false;
            }
            throw err;
        }
    }
    // --------------------------------------------------------------------------------------------
    // GraphQL queries
    // --------------------------------------------------------------------------------------------
    async getStream(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('Getting stream %s', streamId);
        if (streamr_client_protocol_1.StreamIDUtils.isKeyExchangeStream(streamId)) {
            return new Stream_1.Stream({ id: streamId, partitions: 1 }, this.container);
        }
        let metadata;
        try {
            metadata = await this.queryAllReadonlyContracts((contract) => {
                return contract.getStreamMetadata(streamId);
            });
        }
        catch {
            throw new authFetch_1.NotFoundError('Stream not found: id=' + streamId);
        }
        return this.parseStream(streamId, metadata);
    }
    async getStreamFromGraph(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug('Getting stream %s from theGraph', streamId);
        if (streamr_client_protocol_1.StreamIDUtils.isKeyExchangeStream(streamId)) {
            return new Stream_1.Stream({ id: streamId, partitions: 1 }, this.container);
        }
        const response = await this.graphQLClient.sendQuery(StreamRegistry_1.buildGetStreamWithPermissionsQuery(streamId));
        if (!response.stream) {
            throw new authFetch_1.NotFoundError('Stream not found: id=' + streamId);
        }
        return this.parseStream(streamId, response.stream.metadata);
    }
    searchStreams(term, permissionFilter) {
        this.debug('Search streams term=%s permissions=%j', term, permissionFilter);
        return (0, GeneratorUtils_1.map)((0, searchStreams_1.fetchSearchStreamsResultFromTheGraph)(term, permissionFilter, this.graphQLClient), (item) => this.parseStream((0, streamr_client_protocol_1.toStreamID)(item.stream.id), item.stream.metadata));
    }
    getStreamPublishers(streamIdOrPath) {
        return this.getStreamPublishersOrSubscribersList(streamIdOrPath, 'publishExpiration');
    }
    getStreamSubscribers(streamIdOrPath) {
        return this.getStreamPublishersOrSubscribersList(streamIdOrPath, 'subscribeExpiration');
    }
    async *getStreamPublishersOrSubscribersList(streamIdOrPath, fieldName) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.debug(`Get stream ${fieldName}s for stream id ${streamId}`);
        const backendResults = this.graphQLClient.fetchPaginatedResults((lastId, pageSize) => StreamRegistry_1.buildStreamPublishersOrSubscribersQuery(streamId, fieldName, lastId, pageSize));
        /*
         * There can be orphaned permission entities if a stream is deleted (currently
         * we don't remove the assigned permissions, see ETH-222)
         * TODO remove the filtering when ETH-222 has been implemented, and remove also
         * stream result field in buildStreamPublishersOrSubscribersQuery as it is
         * no longer needed
         */
        const validItems = (0, GeneratorUtils_1.filter)(backendResults, (p) => p.stream !== null);
        yield* (0, GeneratorUtils_1.map)(validItems, (item) => item.userAddress);
    }
    static buildStreamPublishersOrSubscribersQuery(streamId, fieldName, lastId, pageSize) {
        const query = `
        {
            permissions (first: ${pageSize}, where: {stream: "${streamId}" ${fieldName}_gt: "${Date.now()}" id_gt: "${lastId}"}) {
                id
                userAddress
                stream {
                    id
                }
            }
        }`;
        return JSON.stringify({ query });
    }
    static formMetadata(props) {
        return JSON.stringify((0, lodash_1.omit)(props, 'id'));
    }
    // @internal
    static buildGetStreamWithPermissionsQuery(streamId) {
        const query = `
        {
            stream (id: "${streamId}") {
                id
                metadata
                permissions {
                    id
                    userAddress
                    canEdit
                    canDelete
                    publishExpiration
                    subscribeExpiration
                    canGrant
                }
            }
        }`;
        return JSON.stringify({ query });
    }
    // --------------------------------------------------------------------------------------------
    // Permissions
    // --------------------------------------------------------------------------------------------
    /* eslint-disable no-else-return */
    async hasPermission(query) {
        const streamId = await this.streamIdBuilder.toStreamID(query.streamId);
        return this.queryAllReadonlyContracts((contract) => {
            const permissionType = (0, permission_1.streamPermissionToSolidityType)(query.permission);
            if ((0, permission_1.isPublicPermissionQuery)(query)) {
                return contract.hasPublicPermission(streamId, permissionType);
            }
            else if (query.allowPublic) {
                return contract.hasPermission(streamId, query.user, permissionType);
            }
            else {
                return contract.hasDirectPermission(streamId, query.user, permissionType);
            }
        });
    }
    async getPermissions(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        const response = await this.graphQLClient.sendQuery(StreamRegistry_1.buildGetStreamWithPermissionsQuery(streamId));
        if (!response.stream) {
            throw new authFetch_1.NotFoundError('stream not found: id: ' + streamId);
        }
        const assignments = [];
        response.stream.permissions
            .forEach((permissionResult) => {
            const permissions = (0, permission_1.convertChainPermissionsToStreamPermissions)(permissionResult);
            /*
             * There can be query results, which don't contain any permissions. That happens if a
             * user revokes all permissions from a stream. Currently we don't remove these empty assignments
             * from The Graph index. TODO remove the "permission.length > 0" if/when we implement the
             * empty assignments cleanup in The Graph.
             */
            if (permissions.length > 0) {
                if (permissionResult.userAddress === permission_1.PUBLIC_PERMISSION_ADDRESS) {
                    assignments.push({
                        public: true,
                        permissions
                    });
                }
                else {
                    assignments.push({
                        user: permissionResult.userAddress,
                        permissions
                    });
                }
            }
        });
        return assignments;
    }
    async grantPermissions(streamIdOrPath, ...assignments) {
        return this.updatePermissions(streamIdOrPath, (streamId, user, solidityType) => {
            return (user === undefined)
                ? this.streamRegistryContract.grantPublicPermission(streamId, solidityType, this.ethereum.getStreamRegistryOverrides())
                : this.streamRegistryContract.grantPermission(streamId, user, solidityType, this.ethereum.getStreamRegistryOverrides());
        }, ...assignments);
    }
    async revokePermissions(streamIdOrPath, ...assignments) {
        return this.updatePermissions(streamIdOrPath, (streamId, user, solidityType) => {
            return (user === undefined)
                ? this.streamRegistryContract.revokePublicPermission(streamId, solidityType, this.ethereum.getStreamRegistryOverrides())
                : this.streamRegistryContract.revokePermission(streamId, user, solidityType, this.ethereum.getStreamRegistryOverrides());
        }, ...assignments);
    }
    async updatePermissions(streamIdOrPath, createTransaction, ...assignments) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.streamEndpointsCached.clearStream(streamId);
        await this.connectToStreamRegistryContract();
        for (const assignment of assignments) {
            for (const permission of assignment.permissions) {
                const solidityType = (0, permission_1.streamPermissionToSolidityType)(permission);
                const user = (0, permission_1.isPublicPermissionAssignment)(assignment) ? undefined : assignment.user;
                const txToSubmit = createTransaction(streamId, user, solidityType);
                // eslint-disable-next-line no-await-in-loop
                await (0, contract_1.waitForTx)(txToSubmit);
            }
        }
    }
    async setPermissions(streamIdOrPath, ...assignments) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        this.streamEndpointsCached.clearStream(streamId);
        await this.connectToStreamRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        const targets = assignments.map((assignment) => {
            return (0, permission_1.isPublicPermissionAssignment)(assignment) ? permission_1.PUBLIC_PERMISSION_ADDRESS : assignment.user;
        });
        const chainPermissions = assignments.map((assignment) => (0, permission_1.convertStreamPermissionsToChainPermission)(assignment.permissions));
        const txToSubmit = this.streamRegistryContract.setPermissions(streamId, targets, chainPermissions, ethersOverrides);
        await (0, contract_1.waitForTx)(txToSubmit);
    }
    async isStreamPublisher(streamIdOrPath, userAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        try {
            return await this.queryAllReadonlyContracts((contract) => {
                return contract.hasPermission(streamId, userAddress, (0, permission_1.streamPermissionToSolidityType)(permission_1.StreamPermission.PUBLISH));
            });
        }
        catch {
            throw new authFetch_1.NotFoundError('stream not found: id: ' + streamId);
        }
    }
    async isStreamSubscriber(streamIdOrPath, userAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        try {
            return await this.queryAllReadonlyContracts((contract) => {
                return contract.hasPermission(streamId, userAddress, (0, permission_1.streamPermissionToSolidityType)(permission_1.StreamPermission.SUBSCRIBE));
            });
        }
        catch {
            throw new authFetch_1.NotFoundError('stream not found: id: ' + streamId);
        }
    }
    // --------------------------------------------------------------------------------------------
    // Helpers
    // --------------------------------------------------------------------------------------------
    queryAllReadonlyContracts(call) {
        return Promise.any([
            ...this.streamRegistryContractsReadonly.map((contract) => {
                return call(contract);
            })
        ]);
    }
};
StreamRegistry = StreamRegistry_1 = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(1, (0, tsyringe_1.inject)(Ethereum_1.default)),
    __param(2, (0, tsyringe_1.inject)(StreamIDBuilder_1.StreamIDBuilder)),
    __param(3, (0, tsyringe_1.inject)(Container_1.BrubeckContainer)),
    __param(4, (0, tsyringe_1.inject)(Config_1.Config.Root)),
    __param(5, (0, tsyringe_1.inject)(GraphQLClient_1.GraphQLClient)),
    __param(6, (0, tsyringe_1.inject)(StreamEndpointsCached_1.StreamEndpointsCached)),
    __metadata("design:paramtypes", [Context_1.Context,
        Ethereum_1.default,
        StreamIDBuilder_1.StreamIDBuilder, Object, Object, GraphQLClient_1.GraphQLClient,
        StreamEndpointsCached_1.StreamEndpointsCached])
], StreamRegistry);
exports.StreamRegistry = StreamRegistry;
//# sourceMappingURL=StreamRegistry.js.map