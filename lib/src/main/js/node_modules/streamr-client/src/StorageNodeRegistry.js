"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var StorageNodeRegistry_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageNodeRegistry = void 0;
const contracts_1 = require("@ethersproject/contracts");
const debug_1 = __importDefault(require("debug"));
const NodeRegistryAbi_json_1 = __importDefault(require("./ethereumArtifacts/NodeRegistryAbi.json"));
const StreamStorageRegistry_json_1 = __importDefault(require("./ethereumArtifacts/StreamStorageRegistry.json"));
const tsyringe_1 = require("tsyringe");
const Container_1 = require("./Container");
const Config_1 = require("./Config");
const Stream_1 = require("./Stream");
const Ethereum_1 = __importDefault(require("./Ethereum"));
const _1 = require(".");
const utils_1 = require("./utils");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const StreamIDBuilder_1 = require("./StreamIDBuilder");
const contract_1 = require("./utils/contract");
const HttpFetcher_1 = require("./utils/HttpFetcher");
const log = (0, debug_1.default)('StreamrClient:StorageNodeRegistry');
let StorageNodeRegistry = StorageNodeRegistry_1 = class StorageNodeRegistry {
    constructor(container, ethereum, streamIdBuilder, httpFetcher, clientConfig) {
        this.container = container;
        this.ethereum = ethereum;
        this.streamIdBuilder = streamIdBuilder;
        this.httpFetcher = httpFetcher;
        this.clientConfig = clientConfig;
        this.chainProvider = this.ethereum.getStreamRegistryChainProvider();
        this.streamStorageRegistryContractReadonly = (0, contract_1.withErrorHandlingAndLogging)(new contracts_1.Contract(this.clientConfig.streamStorageRegistryChainAddress, StreamStorageRegistry_json_1.default, this.chainProvider), 'streamStorageRegistry');
    }
    // --------------------------------------------------------------------------------------------
    // Read from the NodeRegistry or StreamStorageRegistry contract
    // --------------------------------------------------------------------------------------------
    async isStreamStoredInStorageNodeFromContract(streamIdOrPath, nodeAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        log('Checking if stream %s is stored in storage node %s', streamId, nodeAddress);
        return this.streamStorageRegistryContractReadonly.isStorageNodeOf(streamId, nodeAddress.toLowerCase());
    }
    // --------------------------------------------------------------------------------------------
    // Send transactions to the StreamRegistry or StreamStorageRegistry contract
    // --------------------------------------------------------------------------------------------
    async connectToNodeRegistryContract() {
        if (!this.chainSigner || !this.nodeRegistryContract) {
            this.chainSigner = await this.ethereum.getStreamRegistryChainSigner();
            this.nodeRegistryContract = (0, contract_1.withErrorHandlingAndLogging)(new contracts_1.Contract(this.clientConfig.storageNodeRegistryChainAddress, NodeRegistryAbi_json_1.default, this.chainSigner), 'storageNodeRegistry');
            this.streamStorageRegistryContract = (0, contract_1.withErrorHandlingAndLogging)(new contracts_1.Contract(this.clientConfig.streamStorageRegistryChainAddress, StreamStorageRegistry_json_1.default, this.chainSigner), 'streamStorageRegistry');
        }
    }
    async createOrUpdateNodeInStorageNodeRegistry(nodeMetadata) {
        log('createOrUpdateNodeInStorageNodeRegistry %s -> %s', nodeMetadata);
        await this.connectToNodeRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.nodeRegistryContract.createOrUpdateNodeSelf(nodeMetadata, ethersOverrides));
        const nodeAddress = await this.ethereum.getAddress();
        await (0, utils_1.until)(async () => {
            try {
                const url = await this.getStorageNodeUrl(nodeAddress);
                return nodeMetadata.includes(url);
            }
            catch (err) {
                return false;
            }
        }, 
        // eslint-disable-next-line no-underscore-dangle
        this.clientConfig._timeouts.theGraph.timeout, 
        // eslint-disable-next-line no-underscore-dangle
        this.clientConfig._timeouts.theGraph.retryInterval, () => `Failed to create/update node ${nodeAddress}, timed out querying fact from theGraph`);
    }
    async removeNodeFromStorageNodeRegistry() {
        log('removeNodeFromStorageNodeRegistry called');
        await this.connectToNodeRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.nodeRegistryContract.removeNodeSelf(ethersOverrides));
    }
    async addStreamToStorageNode(streamIdOrPath, nodeAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        log('Adding stream %s to node %s', streamId, nodeAddress);
        await this.connectToNodeRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.streamStorageRegistryContract.addStorageNode(streamId, nodeAddress, ethersOverrides));
        await (0, utils_1.until)(async () => this.isStreamStoredInStorageNode(streamId, nodeAddress), 
        // eslint-disable-next-line no-underscore-dangle
        this.clientConfig._timeouts.theGraph.timeout, 
        // eslint-disable-next-line no-underscore-dangle
        this.clientConfig._timeouts.theGraph.retryInterval, () => `Failed to add stream ${streamId} to storageNode ${nodeAddress}, timed out querying fact from theGraph`);
    }
    async removeStreamFromStorageNode(streamIdOrPath, nodeAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        log('Removing stream %s from node %s', streamId, nodeAddress);
        await this.connectToNodeRegistryContract();
        const ethersOverrides = this.ethereum.getStreamRegistryOverrides();
        await (0, contract_1.waitForTx)(this.streamStorageRegistryContract.removeStorageNode(streamId, nodeAddress, ethersOverrides));
    }
    // --------------------------------------------------------------------------------------------
    // GraphQL queries
    // --------------------------------------------------------------------------------------------
    async getStorageNodeUrl(nodeAddress) {
        log('getnode %s ', nodeAddress);
        const res = await this.sendNodeQuery(StorageNodeRegistry_1.buildGetNodeQuery(nodeAddress.toLowerCase()));
        if (res.node === null) {
            throw new _1.NotFoundError('Node not found, id: ' + nodeAddress);
        }
        const metadata = JSON.parse(res.node.metadata);
        return metadata.http;
    }
    async isStreamStoredInStorageNode(streamIdOrPath, nodeAddress) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        log('Checking if stream %s is stored in storage node %s', streamId, nodeAddress);
        const res = await this.sendNodeQuery(StorageNodeRegistry_1.buildStorageNodeQuery(nodeAddress.toLowerCase()));
        if (res.node === null) {
            throw new _1.NotFoundError('Node not found, id: ' + nodeAddress);
        }
        const found = res.node.storedStreams.find((stream) => stream.id === streamId);
        return found !== undefined;
    }
    async getStorageNodesOf(streamIdOrPath) {
        const streamId = await this.streamIdBuilder.toStreamID(streamIdOrPath);
        log('Getting storage nodes of stream %s', streamId);
        const res = await this.sendNodeQuery(StorageNodeRegistry_1.buildStoredStreamQuery(streamId));
        if (res.stream === null) {
            return [];
        }
        return res.stream.storageNodes.map((node) => node.id);
    }
    async getStoredStreamsOf(nodeAddress) {
        log('Getting stored streams of node %s', nodeAddress);
        const res = await this.sendNodeQuery(StorageNodeRegistry_1.buildStorageNodeQuery(nodeAddress.toLowerCase()));
        const streams = res.node.storedStreams.map((stream) => {
            const props = Stream_1.Stream.parsePropertiesFromMetadata(stream.metadata);
            return new Stream_1.Stream({ ...props, id: (0, streamr_client_protocol_1.toStreamID)(stream.id) }, this.container); // toStreamID() not strictly necessary
        });
        return {
            streams,
            // eslint-disable-next-line no-underscore-dangle
            blockNumber: res._meta.block.number
        };
    }
    async getAllStorageNodes() {
        log('Getting all storage nodes');
        const res = await this.sendNodeQuery(StorageNodeRegistry_1.buildAllNodesQuery());
        return res.nodes.map((node) => node.id);
    }
    async sendNodeQuery(gqlQuery) {
        log('GraphQL query: %s', gqlQuery);
        const res = await this.httpFetcher.fetch(this.clientConfig.theGraphUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                accept: '*/*',
            },
            body: gqlQuery
        });
        const resJson = await res.json();
        log('GraphQL response: %o', resJson);
        if (!resJson.data) {
            if (resJson.errors && resJson.errors.length > 0) {
                throw new Error('GraphQL query failed: ' + JSON.stringify(resJson.errors.map((e) => e.message)));
            }
            else {
                throw new Error('GraphQL query failed');
            }
        }
        return resJson.data;
    }
    async registerStorageEventListener(callback) {
        this.streamStorageRegistryContractReadonly.on('Added', (streamId, nodeAddress, extra) => {
            callback({ streamId, nodeAddress, type: 'added', blockNumber: extra.blockNumber });
        });
        this.streamStorageRegistryContractReadonly.on('Removed', (streamId, nodeAddress, extra) => {
            callback({ streamId, nodeAddress, type: 'removed', blockNumber: extra.blockNumber });
        });
    }
    async unRegisterStorageEventListeners() {
        this.streamStorageRegistryContractReadonly.removeAllListeners();
    }
    // --------------------------------------------------------------------------------------------
    // GraphQL query builders
    // --------------------------------------------------------------------------------------------
    // graphql over fetch:
    // https://stackoverflow.com/questions/44610310/node-fetch-post-request-using-graphql-query
    static buildAllNodesQuery() {
        const query = `{
            nodes {
                id,
                metadata,
                lastSeen
            }
        }`;
        return JSON.stringify({ query });
    }
    static buildGetNodeQuery(nodeAddress) {
        const query = `{
            node (id: "${nodeAddress}") {
                id,
                metadata,
                lastSeen
            }
        }`;
        return JSON.stringify({ query });
    }
    static buildStoredStreamQuery(streamId) {
        const query = `{
            stream (id: "${streamId}") {
                id,
                metadata,
                storageNodes {
                    id,
                    metadata,
                    lastSeen,
                }
            }
        }`;
        return JSON.stringify({ query });
    }
    static buildStorageNodeQuery(nodeAddress) {
        const query = `{
            node (id: "${nodeAddress}") {
                id,
                metadata,
                lastSeen,
                storedStreams (first:1000) {
                    id,
                    metadata,
                }
            }
            _meta {
                block {
                    number
                }
            }
        }`;
        return JSON.stringify({ query });
    }
    async stop() {
        // if (!this.didInitialize) {
        //     return
        // }
        //     const contractTask = this.getContract()
        //     this.getContract.reset()
        // nodeRegistryContract?: NodeRegistryContract
        // this.didInitialize = false
        // const contract = await contractTask
        if (this.nodeRegistryContract) {
            this.nodeRegistryContract.removeAllListeners();
            this.nodeRegistryContract.provider.removeAllListeners();
        }
    }
};
StorageNodeRegistry = StorageNodeRegistry_1 = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, (0, tsyringe_1.inject)(Container_1.BrubeckContainer)),
    __param(1, (0, tsyringe_1.inject)(Ethereum_1.default)),
    __param(2, (0, tsyringe_1.inject)(StreamIDBuilder_1.StreamIDBuilder)),
    __param(3, (0, tsyringe_1.inject)(HttpFetcher_1.HttpFetcher)),
    __param(4, (0, tsyringe_1.inject)(Config_1.Config.Root)),
    __metadata("design:paramtypes", [Object, Ethereum_1.default,
        StreamIDBuilder_1.StreamIDBuilder,
        HttpFetcher_1.HttpFetcher, Object])
], StorageNodeRegistry);
exports.StorageNodeRegistry = StorageNodeRegistry;
//# sourceMappingURL=StorageNodeRegistry.js.map