"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withErrorHandlingAndLogging = exports.waitForTx = void 0;
const debug_1 = __importDefault(require("debug"));
const streamr_network_1 = require("streamr-network");
const log = (0, debug_1.default)('Streamr:contract');
async function waitForTx(txToSubmit) {
    const tx = await txToSubmit;
    return tx.wait();
}
exports.waitForTx = waitForTx;
const isTransaction = (returnValue) => {
    return (returnValue.wait !== undefined && (typeof returnValue.wait === 'function'));
};
const createLogger = () => {
    return {
        onMethodExecute: (methodName) => {
            log(`execute ${methodName}`);
        },
        onTransactionSubmit: (methodName, tx) => {
            log('transaction submitted { method=%s, tx=%s, to=%s, nonce=%d, gasLimit=%d, gasPrice=%d }', methodName, tx.hash, streamr_network_1.NameDirectory.getName(tx.to), tx.nonce, tx.gasLimit, tx.gasPrice);
        },
        onTransactionConfirm: (methodName, tx, receipt) => {
            log('transaction confirmed { method=%s, tx=%s, block=%d, confirmations=%d, gasUsed=%d, events=%j }', methodName, tx.hash, receipt.blockNumber, receipt.confirmations, receipt.gasUsed, (receipt.events || []).map((e) => e.event));
        }
    };
};
const withErrorHandling = async (execute, methodName) => {
    try {
        return await execute();
    }
    catch (e) {
        const wrappedError = new Error(`Error in contract call "${methodName}"`);
        // @ts-expect-error
        wrappedError.reason = e;
        throw wrappedError;
    }
};
const createWrappedContractMethod = (originalMethod, methodName, logger) => {
    return async (...args) => {
        logger.onMethodExecute(methodName);
        const returnValue = await withErrorHandling(() => originalMethod(...args), methodName);
        if (isTransaction(returnValue)) {
            const tx = returnValue;
            const originalWaitMethod = tx.wait;
            tx.wait = async (confirmations) => {
                const receipt = await withErrorHandling(() => originalWaitMethod(confirmations), `${methodName}.wait`);
                logger.onTransactionConfirm(methodName, tx, receipt);
                return receipt;
            };
            logger.onTransactionSubmit(methodName, tx);
        }
        return returnValue;
    };
};
/**
 * You can use the wrapped contract normally, e.g.:
 *     const tx = await contract.createFoobar(123)
 *     return await tx.wait()
 * or
 *     await contract.getFoobar(456)
 */
const withErrorHandlingAndLogging = (contract, contractName) => {
    const methods = {};
    /*
     * Wrap each contract function. We read the list of functions from contract.functions, but
     * actually delegate each method to contract[methodName]. Those methods are almost identical
     * to contract.functions[methodName] methods. The major difference is the way of handling
     * single-value results: the return type of contract.functions[methodName] is always
     * Promise<Result> (see https://docs.ethers.io/v5/api/contract/contract/#Contract--readonly)
     */
    Object.keys(contract.functions).forEach((methodName) => {
        methods[methodName] = createWrappedContractMethod(contract[methodName], `${contractName}.${methodName}`, createLogger());
    });
    const clone = {};
    // copy own properties and inherited properties (e.g. contract.removeAllListeners)
    // eslint-disable-next-line
    for (const key in contract) {
        clone[key] = methods[key] !== undefined ? methods[key] : contract[key];
    }
    return clone;
};
exports.withErrorHandlingAndLogging = withErrorHandlingAndLogging;
//# sourceMappingURL=contract.js.map