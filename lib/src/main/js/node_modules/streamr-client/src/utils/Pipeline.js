"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPipeline = exports.Pipeline = void 0;
const index_1 = require("./index");
const log_1 = require("./log");
const iterators_1 = require("./iterators");
const PushBuffer_1 = require("./PushBuffer");
const Context_1 = require("./Context");
const G = __importStar(require("./GeneratorUtils"));
const Signal_1 = __importStar(require("./Signal"));
class PipelineError extends Context_1.ContextError {
}
class PipelineDefinition {
    constructor(context, source, transforms = [], transformsBefore = []) {
        this.transforms = transforms;
        this.transformsBefore = transformsBefore;
        this.id = (0, index_1.instanceId)(this);
        this.debug = context.debug.extend(this.id);
        // this.debug('create')
        this.source = this.setSource(source);
    }
    /**
     * Append a transformation step to this pipeline.
     * Changes the pipeline's output type to output type of this generator.
     */
    pipe(fn) {
        this.transforms.push(fn);
        return this;
    }
    /**
     * Inject pipeline step before other transforms.
     * Note must return same type as source, otherwise we can't be type-safe.
     */
    pipeBefore(fn) {
        this.transformsBefore.push(fn);
        return this;
    }
    clearTransforms() {
        this.transforms.length = 0;
        this.transformsBefore.length = 0;
    }
    setSource(source) {
        const id = 'id' in source ? source.id : (0, index_1.instanceId)(source, 'Source'); // eslint-disable-line no-param-reassign
        this.source = Object.assign(source, {
            id,
        });
        return this.source;
    }
    getTransforms() {
        return [...this.transformsBefore, ...this.transforms];
    }
}
class Pipeline {
    constructor(source, definition) {
        this.source = source;
        this.isIterating = false;
        this.isCleaningUp = false;
        /**
         * Triggers once when pipeline ends.
         * Usage: `pipeline.onFinally(callback)`
         */
        this.onFinally = Signal_1.default.once();
        /**
         * Triggers once when pipeline is about to end.
         */
        this.onBeforeFinally = Signal_1.default.once();
        /**
         * Triggers once when pipeline starts flowing.
         * Usage: `pipeline.onStart(callback)`
         */
        this.onStart = Signal_1.default.once();
        this.onMessage = Signal_1.default.create();
        // eslint-disable-next-line func-call-spacing, no-spaced-func
        this.onError = Signal_1.ErrorSignal.create();
        this.id = (0, index_1.instanceId)(this);
        this.debug = (0, log_1.Debug)(this.id);
        this.definition = definition || new PipelineDefinition(this, source);
        this.cleanup = (0, index_1.pOnce)(this.cleanup.bind(this));
        this.iterator = (0, iterators_1.iteratorFinally)(this.iterate(), this.cleanup);
        this.handleError = this.handleError.bind(this);
    }
    /**
     * Append a transformation step to this pipeline.
     * Changes the pipeline's output type to output type of this generator.
     */
    pipe(fn) {
        if (this.isIterating) {
            throw new PipelineError(this, `cannot pipe after already iterating: ${this.isIterating}`);
        }
        this.definition.pipe(fn);
        // this allows .pipe chaining to be type aware
        // i.e. new Pipeline(Type1).pipe(Type1 => Type2).pipe(Type2 => Type3)
        return this;
    }
    /**
     * Inject pipeline step before other transforms.
     * Note must return same type as source, otherwise we can't be type-safe.
     */
    pipeBefore(fn) {
        if (this.isIterating) {
            throw new PipelineError(this, `cannot pipe after already iterating: ${this.isIterating}`);
        }
        this.definition.pipeBefore(fn);
        return this;
    }
    /**
     * Fires this callback the moment this part of the pipeline starts returning.
     */
    onConsumed(fn) {
        return this.pipe(async function* onConsumed(src) {
            try {
                yield* src;
            }
            finally {
                await fn();
            }
        });
    }
    map(fn) {
        return this.pipe((src) => G.map(src, fn, this.onError.trigger));
    }
    mapBefore(fn) {
        return this.pipeBefore((src) => G.map(src, fn, this.onError.trigger));
    }
    forEach(fn) {
        return this.pipe((src) => G.forEach(src, fn, this.onError.trigger));
    }
    filter(fn) {
        return this.pipe((src) => G.filter(src, fn, this.onError.trigger));
    }
    reduce(fn, initialValue) {
        return this.pipe((src) => G.reduce(src, fn, initialValue, this.onError.trigger));
    }
    forEachBefore(fn) {
        return this.pipeBefore((src) => G.forEach(src, fn, this.onError.trigger));
    }
    filterBefore(fn) {
        return this.pipeBefore((src) => G.filter(src, fn, this.onError.trigger));
    }
    async consume(fn) {
        return G.consume(this, fn, this.handleError);
    }
    collect(n) {
        return G.collect(this, n, this.handleError);
    }
    flow() {
        setImmediate(() => {
            // consume if not already doing so
            if (!this.isIterating) {
                this.consume();
            }
        });
        return this;
    }
    async cleanup(error) {
        this.isCleaningUp = true;
        try {
            try {
                if (error) {
                    await this.onError.trigger(error);
                }
            }
            finally {
                await this.definition.source.return(undefined);
            }
        }
        finally {
            await this.onBeforeFinally.trigger();
            await this.onFinally.trigger(error);
            this.definition.clearTransforms();
        }
    }
    async handleError(err) {
        await this.onError.trigger(err);
    }
    async *iterate() {
        this.isIterating = true;
        await this.onStart.trigger();
        // this.debug('iterate', this.definition.source)
        if (!this.definition.source) {
            throw new PipelineError(this, 'no source');
        }
        const transforms = this.definition.getTransforms();
        // this.debug('transforms', transforms)
        // each pipeline step creates a generator
        // which is then passed into the next transform
        // end result is output of last transform's generator
        const pipeline = transforms.reduce((prev, transform) => {
            return transform(prev);
        }, this.definition.source);
        try {
            for await (const msg of pipeline) {
                await this.onMessage.trigger(msg);
                yield msg;
            }
            this.isCleaningUp = true;
        }
        catch (err) {
            this.isCleaningUp = true;
            await this.handleError(err);
        }
        finally {
            this.isCleaningUp = true;
            if (!this.onBeforeFinally.triggerCount) {
                await this.onBeforeFinally.trigger();
            }
        }
    }
    // AsyncGenerator implementation
    async throw(err) {
        if (this.isCleaningUp) {
            throw err;
        }
        if (!this.onBeforeFinally.triggerCount) {
            await this.onBeforeFinally.trigger();
        }
        // eslint-disable-next-line promise/no-promise-in-callback
        await this.definition.source.throw(err).catch(() => { });
        return this.iterator.throw(err);
    }
    async return(v) {
        if (this.isCleaningUp) {
            return Promise.resolve({ done: true, value: v });
        }
        if (!this.onBeforeFinally.triggerCount) {
            await this.onBeforeFinally.trigger();
        }
        await this.definition.source.return(undefined);
        return this.iterator.return(v);
    }
    async next() {
        return this.iterator.next();
    }
    /**
     * Create a new Pipeline forked from this pipeline.
     * Pushes results into fork.
     * Note: Does not start consuming this pipeline.
     */
    [Symbol.asyncIterator]() {
        if (this.isIterating) {
            throw new PipelineError(this, 'already iterating');
        }
        return this;
    }
}
exports.Pipeline = Pipeline;
/**
 * Pipeline that is also a PushBuffer.
 * i.e. can call .push to push data into pipeline and .pipe to transform it.
 */
class PushPipeline extends Pipeline {
    constructor(bufferSize = PushBuffer_1.DEFAULT_BUFFER_SIZE, options) {
        const inputBuffer = new PushBuffer_1.PushBuffer(bufferSize, options);
        super(inputBuffer);
        this.source = inputBuffer;
    }
    pipe(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        super.pipe(fn);
        return this;
    }
    map(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.map(fn);
    }
    mapBefore(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.mapBefore(fn);
    }
    filterBefore(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.filterBefore(fn);
    }
    filter(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.filter(fn);
    }
    forEach(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.forEach(fn);
    }
    forEachBefore(fn) {
        // this method override just fixes the output type to be PushPipeline rather than Pipeline
        return super.forEachBefore(fn);
    }
    pull(source) {
        return (0, PushBuffer_1.pull)(source, this);
    }
    // wrapped PushBuffer methods below here
    async push(item) {
        return this.source.push(item);
    }
    async handleError(err) {
        try {
            await this.onError.trigger(err);
        }
        catch (error) {
            if (this.isCleaningUp) {
                throw error;
            }
            await this.push(error);
        }
    }
    end(err) {
        return this.source.end(err);
    }
    endWrite(err) {
        return this.source.endWrite(err);
    }
    isDone() {
        return this.source.isDone();
    }
    get length() {
        return this.source.length || 0;
    }
    isFull() {
        return this.source.isFull();
    }
    clear() {
        return this.source.clear();
    }
}
exports.PushPipeline = PushPipeline;
//# sourceMappingURL=Pipeline.js.map