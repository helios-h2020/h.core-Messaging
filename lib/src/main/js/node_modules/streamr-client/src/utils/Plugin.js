"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
/**
 * Take prototype functions from srcInstance and attach them to targetInstance while keeping them bound to srcInstance.
 */
function Plugin(targetInstance, srcInstance) {
    const protoDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(srcInstance));
    const ownDescriptors = Object.getOwnPropertyDescriptors(srcInstance);
    // have to iterate over set of ownKeys otherwise we miss Symbol properties
    const keys = new Set([
        ...Reflect.ownKeys(protoDescriptors),
        ...Reflect.ownKeys(ownDescriptors)
    ]);
    const descriptors = [...keys].map((key) => {
        // @ts-expect-error key can be a symbol, that's ok.
        return [key, key in ownDescriptors ? ownDescriptors[key] : protoDescriptors[key]];
    });
    return descriptors.reduce((target, [key, { value }]) => {
        if (typeof value !== 'function') {
            return target;
        }
        if (key in target) {
            return target; // do nothing if already has property
        }
        // @ts-expect-error ??
        // eslint-disable-next-line no-param-reassign
        target[key] = (...args) => {
            // @ts-expect-error ??
            return srcInstance[key].call(srcInstance, ...args);
        };
        return target;
    }, targetInstance);
}
exports.Plugin = Plugin;
//# sourceMappingURL=Plugin.js.map