"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumConfig = void 0;
/**
 * Config and utilities for interating with identity & Ethereum chain.
 */
const tsyringe_1 = require("tsyringe");
const wallet_1 = require("@ethersproject/wallet");
const providers_1 = require("@ethersproject/providers");
const transactions_1 = require("@ethersproject/transactions");
const address_1 = require("@ethersproject/address");
const Config_1 = require("./Config");
class EthereumConfig {
}
exports.EthereumConfig = EthereumConfig;
let StreamrEthereum = class StreamrEthereum {
    constructor(authConfig, ethereumConfig) {
        this.ethereumConfig = ethereumConfig;
        if ('privateKey' in authConfig && authConfig.privateKey) {
            const key = authConfig.privateKey;
            const address = (0, address_1.getAddress)((0, transactions_1.computeAddress)(key));
            this._getAddress = async () => address;
            this._getSigner = () => new wallet_1.Wallet(key, this.getMainnetProvider());
            this._getDataUnionChainSigner = async () => new wallet_1.Wallet(key, this.getDataUnionChainProvider());
            this._getStreamRegistryChainSigner = async () => new wallet_1.Wallet(key, this.getStreamRegistryChainProvider());
        }
        else if ('ethereum' in authConfig && authConfig.ethereum) {
            const { ethereum } = authConfig;
            this._getAddress = async () => {
                try {
                    if (!(ethereumConfig && 'request' in ethereum && typeof ethereum.request === 'function')) {
                        throw new Error(`invalid ethereum provider ${ethereumConfig}`);
                    }
                    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                    const account = (0, address_1.getAddress)(accounts[0]); // convert to checksum case
                    return account;
                }
                catch {
                    throw new Error('no addresses connected+selected in Metamask');
                }
            };
            this._getSigner = () => {
                const metamaskProvider = new providers_1.Web3Provider(ethereum);
                const metamaskSigner = metamaskProvider.getSigner();
                return metamaskSigner;
            };
            this._getDataUnionChainSigner = async () => {
                if (!ethereumConfig.dataUnionChainRPCs || ethereumConfig.dataUnionChainRPCs.chainId === undefined) {
                    throw new Error('Streamr dataUnionChainRPC not configured (with chainId) in the StreamrClient options!');
                }
                const metamaskProvider = new providers_1.Web3Provider(ethereum);
                const { chainId } = await metamaskProvider.getNetwork();
                if (chainId !== ethereumConfig.dataUnionChainRPCs.chainId) {
                    const sideChainId = ethereumConfig.dataUnionChainRPCs.chainId;
                    throw new Error(`Please connect Metamask to Ethereum blockchain with chainId ${sideChainId}: current chainId is ${chainId}`);
                }
                const metamaskSigner = metamaskProvider.getSigner();
                return metamaskSigner;
            };
            this._getStreamRegistryChainSigner = async () => {
                if (!ethereumConfig.streamRegistryChainRPCs || ethereumConfig.streamRegistryChainRPCs.chainId === undefined) {
                    throw new Error('Streamr streamRegistryChainRPC not configured (with chainId) in the StreamrClient options!');
                }
                const metamaskProvider = new providers_1.Web3Provider(ethereum);
                const { chainId } = await metamaskProvider.getNetwork();
                if (chainId !== ethereumConfig.streamRegistryChainRPCs.chainId) {
                    const sideChainId = ethereumConfig.streamRegistryChainRPCs.chainId;
                    throw new Error(`Please connect Metamask to Ethereum blockchain with chainId ${sideChainId}: current chainId is ${chainId}`);
                }
                const metamaskSigner = metamaskProvider.getSigner();
                return metamaskSigner;
            };
            // TODO: handle events
            // ethereum.on('accountsChanged', (accounts) => { })
            // https://docs.metamask.io/guide/ethereum-provider.html#events says:
            //   "We recommend reloading the page unless you have a very good reason not to"
            //   Of course we can't and won't do that, but if we need something chain-dependent...
            // ethereum.on('chainChanged', (chainId) => { window.location.reload() });
        }
    }
    static generateEthereumAccount() {
        const wallet = wallet_1.Wallet.createRandom();
        return {
            address: wallet.address,
            privateKey: wallet.privateKey,
        };
    }
    isAuthenticated() {
        return (this._getAddress !== undefined);
    }
    canEncrypt() {
        return !!(this._getAddress && this._getSigner);
    }
    async getAddress() {
        if (!this._getAddress) {
            // _getAddress is assigned in constructor
            throw new Error('StreamrClient is not authenticated with private key');
        }
        return (await this._getAddress()).toLowerCase();
    }
    getSigner() {
        if (!this._getSigner) {
            // _getSigner is assigned in constructor
            throw new Error("StreamrClient not authenticated! Can't send transactions or sign messages.");
        }
        return this._getSigner();
    }
    async getDataUnionChainSigner() {
        if (!this._getDataUnionChainSigner) {
            // _getDataUnionChainSigner is assigned in constructor
            throw new Error("StreamrClient not authenticated! Can't send transactions or sign messages.");
        }
        return this._getDataUnionChainSigner();
    }
    async getStreamRegistryChainSigner() {
        if (!this._getStreamRegistryChainSigner) {
            // _getDataUnionChainSigner is assigned in constructor
            throw new Error("StreamrClient not authenticated! Can't send transactions or sign messages.");
        }
        return this._getStreamRegistryChainSigner();
    }
    /** @returns Ethers.js Provider, a connection to the Ethereum network (mainnet) */
    getMainnetProvider() {
        return this.getAllMainnetProviders()[0];
    }
    /** @returns Array of Ethers.js Providers, connections to the Ethereum network (mainnet) */
    getAllMainnetProviders() {
        if (!this.ethereumConfig.mainChainRPCs || !this.ethereumConfig.mainChainRPCs.rpcs.length) {
            return [(0, providers_1.getDefaultProvider)()];
        }
        return this.ethereumConfig.mainChainRPCs.rpcs.map((config) => {
            return new providers_1.JsonRpcProvider(config);
        });
    }
    /** @returns Ethers.js Provider, a connection to the Binance Smart Chain */
    getBinanceProvider() {
        return this.getAllBinanceProviders()[0];
    }
    /** @returns Array of Ethers.js Provider, connections to Binance Smart Chain */
    getAllBinanceProviders() {
        if (!this.ethereumConfig.dataUnionBinanceWithdrawalChainRPCs
            || !this.ethereumConfig.dataUnionBinanceWithdrawalChainRPCs.rpcs.length) {
            throw new Error('StreamrClientEthereumConfig has no data union binance withdrawal configuration.');
        }
        return this.ethereumConfig.dataUnionBinanceWithdrawalChainRPCs.rpcs.map((config) => {
            return new providers_1.JsonRpcProvider(config);
        });
    }
    /** @returns Ethers.js Provider, a connection to the Streamr EVM sidechain */
    getDataUnionChainProvider() {
        return this.getAllDataUnionChainProviders()[0];
    }
    /** @returns Array of Ethers.js Provider, connections to the Streamr EVM sidechain */
    getAllDataUnionChainProviders() {
        if (!this.ethereumConfig.dataUnionChainRPCs || !this.ethereumConfig.dataUnionChainRPCs.rpcs.length) {
            throw new Error('EthereumConfig has no dataunion chain configuration.');
        }
        return this.ethereumConfig.dataUnionChainRPCs.rpcs.map((config) => {
            return new providers_1.JsonRpcProvider(config);
        });
    }
    /** @returns Ethers.js Provider, a connection to the Stream Registry Chain */
    getStreamRegistryChainProvider() {
        return this.getAllStreamRegistryChainProviders()[0];
    }
    /** @returns Array of Ethers.js Providers, connections to the Stream Registry Chain */
    getAllStreamRegistryChainProviders() {
        if (!this.ethereumConfig.streamRegistryChainRPCs || !this.ethereumConfig.streamRegistryChainRPCs.rpcs.length) {
            throw new Error('EthereumConfig has no streamRegistryChainRPC configuration.');
        }
        return this.ethereumConfig.streamRegistryChainRPCs.rpcs.map((config) => {
            return new providers_1.JsonRpcProvider(config);
        });
    }
    getMainnetOverrides() {
        return this.getOverrides('ethereum', this.getMainnetProvider());
    }
    getBinanceOverrides() {
        var _a, _b, _c;
        return this.getOverrides((_c = (_b = (_a = this.ethereumConfig) === null || _a === void 0 ? void 0 : _a.dataUnionBinanceWithdrawalChainRPCs) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'binance', this.getBinanceProvider());
    }
    getDataUnionOverrides() {
        var _a, _b, _c;
        return this.getOverrides((_c = (_b = (_a = this.ethereumConfig) === null || _a === void 0 ? void 0 : _a.dataUnionChainRPCs) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'gnosis', this.getDataUnionChainProvider());
    }
    getStreamRegistryOverrides() {
        var _a, _b, _c;
        return this.getOverrides((_c = (_b = (_a = this.ethereumConfig) === null || _a === void 0 ? void 0 : _a.streamRegistryChainRPCs) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'polygon', this.getStreamRegistryChainProvider());
    }
    /**
     * Apply the gasPriceStrategy to the estimated gas price, if given
     * Ethers.js will resolve the gas price promise before sending the tx
     */
    getOverrides(chainName, provider) {
        var _a, _b, _c;
        const chainConfig = (_b = (_a = this.ethereumConfig) === null || _a === void 0 ? void 0 : _a.ethereumNetworks) === null || _b === void 0 ? void 0 : _b[chainName];
        if (!chainConfig) {
            return {};
        }
        const overrides = (_c = chainConfig === null || chainConfig === void 0 ? void 0 : chainConfig.overrides) !== null && _c !== void 0 ? _c : {};
        if (chainConfig.gasPriceStrategy) {
            return {
                ...overrides,
                gasPrice: provider.getGasPrice().then(chainConfig.gasPriceStrategy)
            };
        }
        return overrides;
    }
};
StreamrEthereum = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, (0, tsyringe_1.inject)(Config_1.Config.Auth)),
    __param(1, (0, tsyringe_1.inject)(Config_1.Config.Ethereum)),
    __metadata("design:paramtypes", [Object, EthereumConfig])
], StreamrEthereum);
exports.default = StreamrEthereum;
//# sourceMappingURL=Ethereum.js.map