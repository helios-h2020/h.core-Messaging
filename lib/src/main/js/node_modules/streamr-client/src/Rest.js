"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = exports.createQueryString = void 0;
/**
 * More ergonomic wrapper around fetch/authFetch
 */
const tsyringe_1 = require("tsyringe");
const utils_1 = require("./utils");
const Config_1 = require("./Config");
const authFetch_1 = __importStar(require("./authFetch"));
const Context_1 = require("./utils/Context");
const WebStreamToNodeStream_1 = require("./utils/WebStreamToNodeStream");
const Session_1 = __importDefault(require("./Session"));
const Container_1 = require("./Container");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const split2_1 = __importDefault(require("split2"));
function serialize(body) {
    if (body == null) {
        return undefined;
    }
    return typeof body === 'string' ? body : JSON.stringify(body);
}
const createQueryString = (query) => {
    const withoutEmpty = Object.fromEntries(Object.entries(query).filter(([_k, v]) => v != null));
    return new URLSearchParams(withoutEmpty).toString();
};
exports.createQueryString = createQueryString;
let Rest = class Rest {
    constructor(context, container, options) {
        this.container = container;
        this.options = options;
        this.id = (0, utils_1.instanceId)(this);
        this.debug = context.debug.extend(this.id);
    }
    getUrl(urlParts, query = {}, restUrl = this.options.restUrl) {
        const url = new URL(urlParts.map((s) => encodeURIComponent(s)).join('/'), restUrl + '/');
        url.search = (0, exports.createQueryString)(query);
        return url;
    }
    get session() {
        return this.container.resolve(Session_1.default);
    }
    fetch(urlParts, { query, useSession = true, options, requireNewToken = false, debug = this.debug, restUrl }) {
        const url = this.getUrl(urlParts, query, restUrl);
        const newOptions = {
            ...options,
            session: useSession ? this.session : undefined
        };
        return (0, authFetch_1.default)(url.toString(), newOptions, requireNewToken, debug);
    }
    request(urlParts, { query, useSession = true, options, requireNewToken = false, debug = this.debug, restUrl }) {
        const url = this.getUrl(urlParts, query, restUrl);
        const newOptions = {
            ...options,
            session: useSession ? this.session : undefined
        };
        return (0, authFetch_1.authRequest)(url.toString(), newOptions, requireNewToken, debug);
    }
    post(urlParts, body, options = {}) {
        var _a;
        return this.fetch(urlParts, {
            ...options,
            options: {
                ...options === null || options === void 0 ? void 0 : options.options,
                headers: {
                    'Content-Type': 'application/json',
                    ...(_a = options === null || options === void 0 ? void 0 : options.options) === null || _a === void 0 ? void 0 : _a.headers,
                },
                method: 'POST',
                body: serialize(body),
            }
        });
    }
    get(urlParts, options = {}) {
        return this.fetch(urlParts, {
            ...options,
            options: {
                ...options.options,
                method: 'GET',
            }
        });
    }
    put(urlParts, body, options = {}) {
        var _a;
        return this.fetch(urlParts, {
            ...options,
            options: {
                ...options.options,
                headers: {
                    'Content-Type': 'application/json',
                    ...(_a = options === null || options === void 0 ? void 0 : options.options) === null || _a === void 0 ? void 0 : _a.headers,
                },
                method: 'PUT',
                body: serialize(body),
            }
        });
    }
    del(urlParts, options = {}) {
        return this.fetch(urlParts, {
            ...options,
            options: {
                ...options.options,
                method: 'DELETE',
            }
        });
    }
    async stream(urlParts, options = {}, abortController = new AbortController()) {
        const startTime = Date.now();
        const response = await this.request(urlParts, {
            ...options,
            options: {
                signal: abortController.signal,
                ...options.options,
            }
        });
        if (!response.body) {
            throw new Error('No Response Body');
        }
        const stream = (0, WebStreamToNodeStream_1.WebStreamToNodeStream)(response.body);
        stream.once('close', () => {
            abortController.abort();
        });
        return Object.assign(stream, {
            startTime,
        });
    }
    // TODO this method is very similar to stream() method, maybe we don't need both?
    // eslint-disable-next-line class-methods-use-this
    async fetchStream(url, opts = {}, abortController = new AbortController()) {
        const startTime = Date.now();
        const response = await (0, authFetch_1.authRequest)(url, {
            signal: abortController.signal,
            ...opts,
        });
        if (!response.body) {
            throw new Error('No Response Body');
        }
        try {
            // in the browser, response.body will be a web stream. Convert this into a node stream.
            const source = (0, WebStreamToNodeStream_1.WebStreamToNodeStream)(response.body);
            const stream = source.pipe((0, split2_1.default)((message) => {
                return streamr_client_protocol_1.StreamMessage.deserialize(message);
            }));
            stream.once('close', () => {
                abortController.abort();
            });
            return Object.assign(stream, {
                startTime,
            });
        }
        catch (err) {
            abortController.abort();
            throw err;
        }
    }
};
Rest = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(1, (0, tsyringe_1.inject)(Container_1.BrubeckContainer)),
    __param(2, (0, tsyringe_1.inject)(Config_1.Config.Connection)),
    __metadata("design:paramtypes", [Context_1.Context, Object, Object])
], Rest);
exports.Rest = Rest;
//# sourceMappingURL=Rest.js.map