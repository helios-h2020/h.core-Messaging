"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = exports.GroupKey = void 0;
/**
 * Wrapper for Stream metadata and (some) methods.
 */
const tsyringe_1 = require("tsyringe");
var Encryption_1 = require("./encryption/Encryption");
Object.defineProperty(exports, "GroupKey", { enumerable: true, get: function () { return Encryption_1.GroupKey; } });
const utils_1 = require("./utils");
const Rest_1 = require("./Rest");
const Resends_1 = __importDefault(require("./subscribe/Resends"));
const Publisher_1 = __importDefault(require("./publish/Publisher"));
const StreamRegistry_1 = require("./StreamRegistry");
const Ethereum_1 = __importDefault(require("./Ethereum"));
const StorageNodeRegistry_1 = require("./StorageNodeRegistry");
const Container_1 = require("./Container");
const StreamEndpoints_1 = require("./StreamEndpoints");
const StreamEndpointsCached_1 = require("./StreamEndpointsCached");
const StreamIDBuilder_1 = require("./StreamIDBuilder");
const Config_1 = require("./Config");
const HttpFetcher_1 = require("./utils/HttpFetcher");
const VALID_FIELD_TYPES = ['number', 'string', 'boolean', 'list', 'map'];
function getFieldType(value) {
    const type = typeof value;
    switch (true) {
        case Array.isArray(value): {
            return 'list';
        }
        case type === 'object': {
            return 'map';
        }
        case VALID_FIELD_TYPES.includes(type): {
            // see https://github.com/microsoft/TypeScript/issues/36275
            return type;
        }
        default: {
            return undefined;
        }
    }
}
let StreamrStream = class StreamrStream {
    /** @internal */
    constructor(props, _container) {
        this._container = _container;
        this.config = { fields: [] };
        Object.assign(this, props);
        this.id = props.id;
        this.partitions = props.partitions ? props.partitions : 1;
        this._rest = _container.resolve(Rest_1.Rest);
        this._resends = _container.resolve(Resends_1.default);
        this._publisher = _container.resolve(Publisher_1.default);
        this._streamEndpoints = _container.resolve(StreamEndpoints_1.StreamEndpoints);
        this._streamEndpointsCached = _container.resolve(StreamEndpointsCached_1.StreamEndpointsCached);
        this._streamRegistry = _container.resolve(StreamRegistry_1.StreamRegistry);
        this._nodeRegistry = _container.resolve(StorageNodeRegistry_1.StorageNodeRegistry);
        this._ethereuem = _container.resolve(Ethereum_1.default);
        this._httpFetcher = _container.resolve(HttpFetcher_1.HttpFetcher);
        this._clientConfig = _container.resolve(Config_1.Config.Root);
    }
    /**
     * Persist stream metadata updates.
     */
    async update() {
        try {
            await this._streamRegistry.updateStream(this.toObject());
        }
        finally {
            this._streamEndpointsCached.clearStream(this.id);
        }
    }
    toObject() {
        const result = {};
        Object.keys(this).forEach((key) => {
            if (key.startsWith('_') || typeof key === 'function') {
                return;
            }
            // @ts-expect-error
            result[key] = this[key];
        });
        return result;
    }
    async delete() {
        try {
            await this._streamRegistry.deleteStream(this.id);
        }
        finally {
            this._streamEndpointsCached.clearStream(this.id);
        }
    }
    async detectFields() {
        // Get last message of the stream to be used for field detecting
        const sub = await this._resends.resend(this.id, {
            last: 1,
        });
        const receivedMsgs = await sub.collectContent();
        if (!receivedMsgs.length) {
            return;
        }
        const [lastMessage] = receivedMsgs;
        const fields = Object.entries(lastMessage).map(([name, value]) => {
            const type = getFieldType(value);
            return !!type && {
                name,
                type,
            };
        }).filter(Boolean); // see https://github.com/microsoft/TypeScript/issues/30621
        // Save field config back to the stream
        this.config.fields = fields;
        await this.update();
    }
    async addToStorageNode(nodeAddress, waitOptions = {}) {
        try {
            const storageNodeUrl = await this._nodeRegistry.getStorageNodeUrl(nodeAddress);
            await this._nodeRegistry.addStreamToStorageNode(this.id, nodeAddress);
            await this.waitUntilStorageAssigned(waitOptions, storageNodeUrl);
        }
        finally {
            this._streamEndpointsCached.clearStream(this.id);
        }
    }
    async waitUntilStorageAssigned({ timeout, pollInterval } = {}, url) {
        // wait for propagation: the storage node sees the change and
        // is ready to store the any stream data which we publish
        await (0, utils_1.until)(() => this.isStreamStoredInStorageNode(this.id, url), 
        // eslint-disable-next-line no-underscore-dangle
        timeout !== null && timeout !== void 0 ? timeout : this._clientConfig._timeouts.storageNode.timeout, 
        // eslint-disable-next-line no-underscore-dangle
        pollInterval !== null && pollInterval !== void 0 ? pollInterval : this._clientConfig._timeouts.storageNode.retryInterval, () => `Propagation timeout when adding stream to a storage node: ${this.id}`);
    }
    async isStreamStoredInStorageNode(streamId, nodeurl) {
        const url = `${nodeurl}/streams/${encodeURIComponent(streamId)}/storage/partitions/${StreamIDBuilder_1.DEFAULT_PARTITION}`;
        const response = await this._httpFetcher.fetch(url);
        if (response.status === 200) {
            return true;
        }
        if (response.status === 404) { // eslint-disable-line padding-line-between-statements
            return false;
        }
        throw new Error(`Unexpected response code ${response.status} when fetching stream storage status`);
    }
    async removeFromStorageNode(nodeAddress) {
        try {
            return this._nodeRegistry.removeStreamFromStorageNode(this.id, nodeAddress);
        }
        finally {
            this._streamEndpointsCached.clearStream(this.id);
        }
    }
    async getStorageNodes() {
        return this._nodeRegistry.getStorageNodesOf(this.id);
    }
    async publish(content, timestamp, partitionKey) {
        return this._publisher.publish(this.id, content, timestamp, partitionKey);
    }
    /** @internal */
    static parsePropertiesFromMetadata(propsString) {
        try {
            return JSON.parse(propsString);
        }
        catch (error) {
            throw new Error(`Could not parse properties from onchain metadata: ${propsString}`);
        }
    }
    async hasPermission(query) {
        return this._streamRegistry.hasPermission({
            streamId: this.id,
            ...query
        });
    }
    async getPermissions() {
        return this._streamRegistry.getPermissions(this.id);
    }
    async grantPermissions(...assignments) {
        return this._streamRegistry.grantPermissions(this.id, ...assignments);
    }
    async revokePermissions(...assignments) {
        return this._streamRegistry.revokePermissions(this.id, ...assignments);
    }
};
StreamrStream = __decorate([
    __param(1, (0, tsyringe_1.inject)(Container_1.BrubeckContainer)),
    __metadata("design:paramtypes", [Object, Object])
], StreamrStream);
exports.Stream = StreamrStream;
//# sourceMappingURL=Stream.js.map