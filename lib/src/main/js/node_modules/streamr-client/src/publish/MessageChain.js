"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCachedMessageChain = void 0;
/**
 * MessageChains
 */
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
function getCachedMessageChain(cacheConfig) {
    // one chainer per streamId + streamPartition + publisherId + msgChainId
    return (0, utils_1.CacheFn)((...args) => new MessageChain(...args), {
        cacheKey: ([streamPartId, { publisherId, msgChainId }]) => (
        // empty msgChainId is fine
        [streamPartId, publisherId, msgChainId !== null && msgChainId !== void 0 ? msgChainId : ''].join('|')),
        ...cacheConfig,
        maxAge: Infinity
    });
}
exports.getCachedMessageChain = getCachedMessageChain;
/**
 * Manage sequenceNumber & msgChainId for StreamMessages
 */
class MessageChain {
    constructor(streamPartId, { publisherId, msgChainId = (0, utils_1.randomString)(20) }) {
        [this.streamId, this.streamPartition] = streamr_client_protocol_1.StreamPartIDUtils.getStreamIDAndPartition(streamPartId);
        this.publisherId = publisherId;
        this.msgChainId = msgChainId;
    }
    /**
     * Generate the next message MessageID + previous MessageRef for this message chain.
     * Messages with same timestamp get incremented sequence numbers.
     */
    add(timestamp) {
        const { prevMsgRef, publisherId, msgChainId, streamId, streamPartition } = this;
        // NOTE: publishing back-dated (i.e. non-sequentially timestamped) messages will 'break' sequencing.
        // i.e. we lose track of biggest sequence number whenever timestamp changes for stream id+partition combo
        // so backdated messages will start at sequence 0 again, regardless of the sequencing of existing messages.
        // storage considers timestamp+sequence number unique, so the newer messages will clobber the older messages
        // Not feasible to keep greatest sequence number for every millisecond timestamp so not sure a good way around this.
        // Possible we should keep a global sequence number
        const isSameTimestamp = prevMsgRef && prevMsgRef.timestamp === timestamp;
        const isBackdated = prevMsgRef && prevMsgRef.timestamp > timestamp;
        // increment if timestamp the same, otherwise 0
        const nextSequenceNumber = isSameTimestamp ? prevMsgRef.sequenceNumber + 1 : 0;
        const messageId = new streamr_client_protocol_1.MessageID(streamId, streamPartition, timestamp, nextSequenceNumber, publisherId, msgChainId);
        // update latest timestamp + sequence for this streamId+partition
        // (see note above about clobbering sequencing)
        // don't update latest if timestamp < previous timestamp
        // this "fixes" the sequence breaking issue above, but this message will silently disappear
        const currentPrevMsgRef = prevMsgRef;
        if (!isBackdated) {
            this.prevMsgRef = new streamr_client_protocol_1.MessageRef(timestamp, nextSequenceNumber);
        }
        return [messageId, currentPrevMsgRef];
    }
}
exports.default = MessageChain;
//# sourceMappingURL=MessageChain.js.map