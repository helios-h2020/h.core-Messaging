"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var Signer_1;
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * StreamMessage Signing in-place.
 */
const tsyringe_1 = require("tsyringe");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const providers_1 = require("@ethersproject/providers");
const utils_1 = require("../utils");
const Config_1 = require("../Config");
let Signer = Signer_1 = class Signer {
    constructor(authOptions) {
        this.signData = Signer_1.getSigningFunction(authOptions);
    }
    static getSigningFunction(options) {
        if ('privateKey' in options && options.privateKey) {
            const { privateKey } = options;
            const key = (typeof privateKey === 'string' && privateKey.startsWith('0x'))
                ? privateKey.slice(2) // strip leading 0x
                : privateKey;
            return async (d) => streamr_client_protocol_1.SigningUtil.sign(d, key.toString());
        }
        if ('ethereum' in options && options.ethereum) {
            const { ethereum } = options;
            const web3Provider = new providers_1.Web3Provider(ethereum);
            const signer = web3Provider.getSigner();
            // sign one at a time & wait a moment before asking for next signature
            // otherwise metamask extension may not show the prompt window
            return (0, utils_1.pLimitFn)(async (d) => {
                const sig = await signer.signMessage(d);
                await (0, utils_1.sleep)(50);
                return sig;
            }, 1);
        }
        return async (_d) => {
            throw new Error('Need either "privateKey" or "ethereum".');
        };
    }
    async sign(streamMessage, signatureType = streamr_client_protocol_1.SignatureType.ETH) {
        if (!streamMessage) {
            throw new Error('streamMessage required as part of the data to sign.');
        }
        if (streamr_client_protocol_1.StreamMessage.isSigned(streamMessage)) {
            // already signed
            return streamMessage;
        }
        if (typeof streamMessage.getTimestamp !== 'function' || !streamMessage.getTimestamp()) {
            throw new Error('Timestamp is required as part of the data to sign.');
        }
        if (signatureType !== streamr_client_protocol_1.SignatureType.ETH_LEGACY && signatureType !== streamr_client_protocol_1.SignatureType.ETH) {
            throw new Error(`Unrecognized signature type: ${signatureType}`);
        }
        const signedMessage = Object.assign(streamMessage, {
            signatureType,
            signature: await this.signData(streamMessage.getPayloadToSign(signatureType)),
        });
        return signedMessage;
    }
};
Signer = Signer_1 = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, (0, tsyringe_1.inject)(Config_1.Config.Auth)),
    __metadata("design:paramtypes", [Object])
], Signer);
exports.default = Signer;
//# sourceMappingURL=Signer.js.map