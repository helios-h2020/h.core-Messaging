"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tsyringe_1 = require("tsyringe");
const utils_1 = require("../utils");
const log_1 = require("../utils/log");
const Context_1 = require("../utils/Context");
const iterators_1 = require("../utils/iterators");
const StreamEndpoints_1 = require("../StreamEndpoints");
const PublishPipeline_1 = __importDefault(require("./PublishPipeline"));
const KeyExchangePublisher_1 = require("../encryption/KeyExchangePublisher");
const Validator_1 = __importDefault(require("../Validator"));
const BrubeckNode_1 = __importDefault(require("../BrubeckNode"));
const StreamIDBuilder_1 = require("../StreamIDBuilder");
const Config_1 = require("../Config");
const wait = (ms = 0) => new Promise((resolve) => setTimeout(resolve, ms));
let BrubeckPublisher = class BrubeckPublisher {
    constructor(context, pipeline, node, validator, streamIdBuilder, keyExchange, streamEndpoints, config) {
        this.pipeline = pipeline;
        this.node = node;
        this.validator = validator;
        this.streamIdBuilder = streamIdBuilder;
        this.keyExchange = keyExchange;
        this.streamEndpoints = streamEndpoints;
        this.config = config;
        this.isStopped = false;
        this.inProgress = new Set();
        this.id = (0, utils_1.instanceId)(this);
        this.debug = context.debug.extend(this.id);
        this.streamMessageQueue = pipeline.streamMessageQueue;
        this.publishQueue = pipeline.publishQueue;
    }
    async validateAndPublishStreamMessage(streamMessage) {
        // await this.validator.validate(streamMessage)
        await this.node.publishToNode(streamMessage);
    }
    async publish(streamDefinition, content, timestamp = Date.now(), partitionKey) {
        return this.publishMessage(streamDefinition, {
            content,
            timestamp,
            partitionKey,
        });
    }
    async publishMessage(streamDefinition, { content, timestamp = Date.now(), partitionKey }) {
        const timestampAsNumber = timestamp instanceof Date ? timestamp.getTime() : new Date(timestamp).getTime();
        return this.pipeline.publish({
            streamDefinition,
            content,
            timestamp: timestampAsNumber,
            partitionKey,
        });
    }
    async collect(target, n) {
        const msgs = [];
        for await (const msg of target) {
            if (n === 0) {
                break;
            }
            msgs.push(msg.getParsedContent());
            if (msgs.length === n) {
                break;
            }
        }
        return msgs;
    }
    async collectMessages(target, n) {
        const msgs = [];
        for await (const msg of target) {
            if (n === 0) {
                break;
            }
            msgs.push(msg);
            if (msgs.length === n) {
                break;
            }
        }
        return msgs;
    }
    /** @internal */
    async *publishFrom(streamDefinition, seq) {
        const items = (0, iterators_1.CancelableGenerator)(seq);
        this.inProgress.add(items);
        try {
            for await (const msg of items) {
                yield await this.publish(streamDefinition, msg);
            }
        }
        finally {
            this.inProgress.delete(items);
        }
    }
    /** @internal */
    async *publishFromMetadata(streamDefinition, seq) {
        const items = (0, iterators_1.CancelableGenerator)(seq);
        this.inProgress.add(items);
        try {
            for await (const msg of items) {
                yield await this.publishMessage(streamDefinition, msg);
            }
        }
        finally {
            this.inProgress.delete(items);
        }
    }
    async waitForStorage(streamMessage, { 
    // eslint-disable-next-line no-underscore-dangle
    interval = this.config._timeouts.storageNode.retryInterval, 
    // eslint-disable-next-line no-underscore-dangle
    timeout = this.config._timeouts.storageNode.timeout, count = 100, messageMatchFn = (msgTarget, msgGot) => {
        return msgTarget.signature === msgGot.signature;
    } } = {}) {
        if (!streamMessage) {
            throw new Context_1.ContextError(this, 'waitForStorage requires a StreamMessage, got:', streamMessage);
        }
        /* eslint-disable no-await-in-loop */
        const start = Date.now();
        let last;
        // eslint-disable-next-line no-constant-condition
        let found = false;
        while (!found && !this.isStopped) {
            const duration = Date.now() - start;
            if (duration > timeout) {
                this.debug('waitForStorage timeout %o', {
                    timeout,
                    duration
                }, {
                    streamMessage,
                    last: last.map((l) => l.content),
                });
                const err = new Error(`timed out after ${duration}ms waiting for message: ${(0, log_1.inspect)(streamMessage)}`);
                err.streamMessage = streamMessage;
                throw err;
            }
            last = await this.streamEndpoints.getStreamLast(streamMessage.getStreamPartID(), count);
            for (const lastMsg of last) {
                if (messageMatchFn(streamMessage, lastMsg)) {
                    found = true;
                    this.debug('last message found');
                    return;
                }
            }
            this.debug('message not found, retrying... %o', {
                msg: streamMessage.getParsedContent(),
                'last 3': last.slice(-3).map(({ content }) => content)
            });
            await wait(interval);
        }
        /* eslint-enable no-await-in-loop */
    }
    startKeyExchange() {
        return this.keyExchange.start();
    }
    stopKeyExchange() {
        return this.keyExchange.stop();
    }
    async setPublishProxy(streamDefinition, nodeId) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        await this.node.openPublishProxyConnectionOnStreamPart(streamPartId, nodeId);
    }
    async removePublishProxy(streamDefinition, nodeId) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        await this.node.closePublishProxyConnectionOnStreamPart(streamPartId, nodeId);
    }
    async setPublishProxies(streamDefinition, nodeIds) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        await Promise.allSettled([
            ...nodeIds.map((nodeId) => this.node.openPublishProxyConnectionOnStreamPart(streamPartId, nodeId))
        ]);
    }
    async removePublishProxies(streamDefinition, nodeIds) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        await Promise.allSettled([
            ...nodeIds.map(async (nodeId) => this.node.closePublishProxyConnectionOnStreamPart(streamPartId, nodeId))
        ]);
    }
    async start() {
        this.isStopped = false;
        this.pipeline.start();
    }
    async stop() {
        this.isStopped = true;
        await Promise.allSettled([
            this.pipeline.stop(),
            ...[...this.inProgress].map((item) => item.cancel().catch(() => { }))
        ]);
    }
};
BrubeckPublisher = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(4, (0, tsyringe_1.inject)(StreamIDBuilder_1.StreamIDBuilder)),
    __param(5, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => KeyExchangePublisher_1.PublisherKeyExchange))),
    __param(6, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => StreamEndpoints_1.StreamEndpoints))),
    __param(7, (0, tsyringe_1.inject)(Config_1.Config.Root)),
    __metadata("design:paramtypes", [Context_1.Context,
        PublishPipeline_1.default,
        BrubeckNode_1.default,
        Validator_1.default,
        StreamIDBuilder_1.StreamIDBuilder,
        KeyExchangePublisher_1.PublisherKeyExchange,
        StreamEndpoints_1.StreamEndpoints, Object])
], BrubeckPublisher);
exports.default = BrubeckPublisher;
//# sourceMappingURL=Publisher.js.map