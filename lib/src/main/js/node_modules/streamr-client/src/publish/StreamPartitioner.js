"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Derive partitions for StreamMessages.
 */
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
const Config_1 = require("../Config");
const tsyringe_1 = require("tsyringe");
const StreamEndpointsCached_1 = require("../StreamEndpointsCached");
let StreamPartitioner = class StreamPartitioner {
    constructor(streamEndpoints, cacheOptions) {
        this.streamEndpoints = streamEndpoints;
        this.cacheOptions = cacheOptions;
        this.computeStreamPartition = (0, utils_1.CacheFn)((_streamId, partitionCount, partitionKey) => {
            if (!(Number.isSafeInteger(partitionCount) && partitionCount > 0)) {
                throw new Error(`partitionCount is not a safe positive integer! ${partitionCount}`);
            }
            if (partitionKey == null) {
                // Fallback to random partition if no key
                return Math.floor(Math.random() * partitionCount);
            }
            return streamr_client_protocol_1.Utils.keyToArrayIndex(partitionCount, partitionKey);
        }, {
            ...this.cacheOptions,
            cacheKey([streamId, partitionCount, partitionKey]) {
                return `${streamId}-${partitionCount}-${partitionKey}`;
            }
        });
        // NOTE: ensure cache partitions by streamId + partitionCount.
        // i.e. don't cache on just partitionCount + key
        // otherwise streams with same partition count will all map
        // to the same partition
    }
    async compute(streamId, partitionKey) {
        // no need to fetch stream partition info if partition key is 0
        // partition 0 should always exist
        if (partitionKey === 0) {
            return 0;
        }
        const stream = await this.streamEndpoints.getStream(streamId);
        return this.computeStreamPartition(stream.id, stream.partitions, partitionKey);
    }
    clear() {
        this.computeStreamPartition.clear();
    }
};
StreamPartitioner = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(1, (0, tsyringe_1.inject)(Config_1.Config.Cache)),
    __metadata("design:paramtypes", [StreamEndpointsCached_1.StreamEndpointsCached, Object])
], StreamPartitioner);
exports.default = StreamPartitioner;
//# sourceMappingURL=StreamPartitioner.js.map