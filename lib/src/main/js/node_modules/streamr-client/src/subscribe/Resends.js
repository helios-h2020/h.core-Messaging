"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Public Resends API
 */
const tsyringe_1 = require("tsyringe");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
const Context_1 = require("../utils/Context");
const log_1 = require("../utils/log");
const MessageStream_1 = require("./MessageStream");
const SubscribePipeline_1 = __importDefault(require("./SubscribePipeline"));
const StorageNodeRegistry_1 = require("../StorageNodeRegistry");
const StreamEndpoints_1 = require("../StreamEndpoints");
const Container_1 = require("../Container");
const Rest_1 = require("../Rest");
const StreamIDBuilder_1 = require("../StreamIDBuilder");
const MIN_SEQUENCE_NUMBER_VALUE = 0;
const createUrl = (baseUrl, endpointSuffix, streamPartId, query = {}) => {
    const queryMap = {
        ...query,
        format: 'raw'
    };
    const [streamId, streamPartition] = streamr_client_protocol_1.StreamPartIDUtils.getStreamIDAndPartition(streamPartId);
    const queryString = (0, Rest_1.createQueryString)(queryMap);
    return `${baseUrl}/streams/${encodeURIComponent(streamId)}/data/partitions/${streamPartition}/${endpointSuffix}?${queryString}`;
};
function isResendLast(options) {
    return options && typeof options === 'object' && 'last' in options && options.last != null;
}
function isResendFrom(options) {
    return options && typeof options === 'object' && 'from' in options && !('to' in options) && options.from != null;
}
function isResendRange(options) {
    return options && typeof options === 'object' && 'from' in options && 'to' in options && options.to && options.from != null;
}
let Resend = class Resend {
    constructor(context, storageNodeRegistry, streamIdBuilder, streamEndpoints, rest, container) {
        this.storageNodeRegistry = storageNodeRegistry;
        this.streamIdBuilder = streamIdBuilder;
        this.streamEndpoints = streamEndpoints;
        this.rest = rest;
        this.container = container;
        this.id = (0, utils_1.instanceId)(this);
        this.debug = context.debug.extend(this.id);
    }
    /**
     * Call last/from/range as appropriate based on arguments
     */
    async resend(streamDefinition, options, onMessage) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        const sub = await this.resendMessages(streamPartId, options);
        if (onMessage) {
            sub.useLegacyOnMessageHandler(onMessage);
        }
        return sub;
    }
    resendMessages(streamPartId, options) {
        if (isResendLast(options)) {
            return this.last(streamPartId, {
                count: options.last,
            });
        }
        if (isResendRange(options)) {
            return this.range(streamPartId, {
                fromTimestamp: new Date(options.from.timestamp).getTime(),
                fromSequenceNumber: options.from.sequenceNumber,
                toTimestamp: new Date(options.to.timestamp).getTime(),
                toSequenceNumber: options.to.sequenceNumber,
                publisherId: options.publisherId,
                msgChainId: options.msgChainId,
            });
        }
        if (isResendFrom(options)) {
            return this.from(streamPartId, {
                fromTimestamp: new Date(options.from.timestamp).getTime(),
                fromSequenceNumber: options.from.sequenceNumber,
                publisherId: options.publisherId,
            });
        }
        throw new Context_1.ContextError(this, `can not resend without valid resend options: ${(0, log_1.inspect)({ streamPartId, options })}`);
    }
    async fetchStream(endpointSuffix, streamPartId, query = {}) {
        const debug = this.debug.extend((0, utils_1.counterId)(`resend-${endpointSuffix}`));
        debug('fetching resend %s %s %o', endpointSuffix, streamPartId, query);
        const nodeAdresses = await this.storageNodeRegistry.getStorageNodesOf(streamr_client_protocol_1.StreamPartIDUtils.getStreamID(streamPartId));
        if (!nodeAdresses.length) {
            const err = new Context_1.ContextError(this, `no storage assigned: ${(0, log_1.inspect)(streamPartId)}`);
            err.code = 'NO_STORAGE_NODES';
            throw err;
        }
        const nodeUrl = await this.storageNodeRegistry.getStorageNodeUrl(nodeAdresses[0]); // TODO: handle multiple nodes
        const url = createUrl(nodeUrl, endpointSuffix, streamPartId, query);
        const messageStream = (0, SubscribePipeline_1.default)(new MessageStream_1.MessageStream(this), streamPartId, this.container.resolve(Context_1.Context), this.container);
        let count = 0;
        messageStream.forEach(() => {
            count += 1;
        });
        const dataStream = await this.rest.fetchStream(url);
        messageStream.pull((async function* readStream() {
            try {
                yield* dataStream;
            }
            finally {
                debug('resent %s messages.', count);
                dataStream.destroy();
            }
        }()));
        return messageStream;
    }
    async last(streamPartId, { count }) {
        if (count <= 0) {
            const emptyStream = new MessageStream_1.MessageStream(this);
            emptyStream.endWrite();
            return emptyStream;
        }
        return this.fetchStream('last', streamPartId, {
            count,
        });
    }
    async from(streamPartId, { fromTimestamp, fromSequenceNumber = MIN_SEQUENCE_NUMBER_VALUE, publisherId }) {
        return this.fetchStream('from', streamPartId, {
            fromTimestamp,
            fromSequenceNumber,
            publisherId,
        });
    }
    async range(streamPartId, { fromTimestamp, fromSequenceNumber = MIN_SEQUENCE_NUMBER_VALUE, toTimestamp, toSequenceNumber = MIN_SEQUENCE_NUMBER_VALUE, publisherId, msgChainId }) {
        return this.fetchStream('range', streamPartId, {
            fromTimestamp,
            fromSequenceNumber,
            toTimestamp,
            toSequenceNumber,
            publisherId,
            msgChainId,
        });
    }
    async stop() {
        await this.storageNodeRegistry.stop();
    }
};
Resend = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(1, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => StorageNodeRegistry_1.StorageNodeRegistry))),
    __param(2, (0, tsyringe_1.inject)(StreamIDBuilder_1.StreamIDBuilder)),
    __param(3, (0, tsyringe_1.inject)((0, tsyringe_1.delay)(() => StreamEndpoints_1.StreamEndpoints))),
    __param(4, (0, tsyringe_1.inject)(Rest_1.Rest)),
    __param(5, (0, tsyringe_1.inject)(Container_1.BrubeckContainer)),
    __metadata("design:paramtypes", [Context_1.Context,
        StorageNodeRegistry_1.StorageNodeRegistry,
        StreamIDBuilder_1.StreamIDBuilder,
        StreamEndpoints_1.StreamEndpoints,
        Rest_1.Rest, Object])
], Resend);
exports.default = Resend;
//# sourceMappingURL=Resends.js.map