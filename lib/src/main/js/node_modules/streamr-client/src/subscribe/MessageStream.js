"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageStream = void 0;
/**
 * Wrapper around PushPipeline specific to StreamMessages.
 * Subscriptions are MessageStreams.
 * Not all MessageStreams are Subscriptions.
 */
const Pipeline_1 = require("../utils/Pipeline");
const utils_1 = require("../utils");
const streamr_client_protocol_1 = require("streamr-client-protocol");
// @internal
class MessageStream extends Pipeline_1.PushPipeline {
    constructor(context, { bufferSize, name = '' } = {}) {
        super(bufferSize);
        this.id = (0, utils_1.instanceId)(this, name);
        this.debug = context.debug.extend(this.id);
    }
    /**
     * Attach a legacy onMessage handler and consume if necessary.
     * onMessage is passed parsed content as first arument, and streamMessage as second argument.
     */
    useLegacyOnMessageHandler(onMessage) {
        if (onMessage) {
            this.onMessage(async (streamMessage) => {
                if (streamMessage instanceof streamr_client_protocol_1.StreamMessage) {
                    await onMessage(streamMessage.getParsedContent(), streamMessage);
                }
            });
        }
        this.flow();
        return this;
    }
    async collectContent(n) {
        const messages = await this.collect(n);
        return messages.map((streamMessage) => {
            if (streamMessage instanceof streamr_client_protocol_1.StreamMessage) {
                return streamMessage.getParsedContent();
            }
            return streamMessage;
        });
    }
    pipe(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        super.pipe(fn);
        return this;
    }
    pipeBefore(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        super.pipeBefore(fn);
        return this;
    }
    map(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        return super.map(fn);
    }
    filterBefore(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        return super.filterBefore(fn);
    }
    filter(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        return super.filter(fn);
    }
    forEach(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        return super.forEach(fn);
    }
    forEachBefore(fn) {
        // this method override just fixes the output type to be MessageStream rather than Pipeline
        return super.forEachBefore(fn);
    }
}
exports.MessageStream = MessageStream;
//# sourceMappingURL=MessageStream.js.map