"use strict";
/**
 * Subscription message processing pipeline
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const streamr_client_protocol_1 = require("streamr-client-protocol");
const OrderMessages_1 = __importDefault(require("./OrderMessages"));
const Validator_1 = __importDefault(require("../Validator"));
const Decrypt_1 = require("./Decrypt");
const KeyExchangeSubscriber_1 = require("../encryption/KeyExchangeSubscriber");
const Context_1 = require("../utils/Context");
const Config_1 = require("../Config");
const Resends_1 = __importDefault(require("./Resends"));
const DestroySignal_1 = require("../DestroySignal");
const StreamEndpointsCached_1 = require("../StreamEndpointsCached");
function SubscribePipeline(messageStream, streamPartId, context, container) {
    const validate = new Validator_1.default(context, container.resolve(StreamEndpointsCached_1.StreamEndpointsCached), container.resolve(Config_1.Config.Subscribe), container.resolve(Config_1.Config.Cache));
    const gapFillMessages = new OrderMessages_1.default(container.resolve(Config_1.Config.Subscribe), container.resolve(Context_1.Context), container.resolve(Resends_1.default), streamPartId);
    const orderMessages = new OrderMessages_1.default({
        ...container.resolve(Config_1.Config.Subscribe),
        gapFill: false,
    }, container.resolve(Context_1.Context), container.resolve(Resends_1.default), streamPartId);
    /* eslint-enable object-curly-newline */
    const onError = async (error, streamMessage) => {
        if (streamMessage) {
            ignoreMessages.add(streamMessage);
        }
        if (error && 'streamMessage' in error && error.streamMessage) {
            ignoreMessages.add(error.streamMessage);
        }
        throw error;
    };
    const decrypt = new Decrypt_1.Decrypt(context, container.resolve(StreamEndpointsCached_1.StreamEndpointsCached), container.resolve(KeyExchangeSubscriber_1.SubscriberKeyExchange), container.resolve(DestroySignal_1.DestroySignal));
    // collect messages that fail validation/parsing, do not push out of pipeline
    // NOTE: we let failed messages be processed and only removed at end so they don't
    // end up acting as gaps that we repeatedly try to fill.
    const ignoreMessages = new WeakSet();
    return messageStream
        .onError(onError)
        // order messages (fill gaps)
        .pipe(gapFillMessages.transform())
        // convert group key error responses into errors
        // (only for subscribe pipeline, not publish pipeline)
        .forEach((streamMessage) => {
        if (streamMessage.messageType === streamr_client_protocol_1.StreamMessage.MESSAGE_TYPES.GROUP_KEY_ERROR_RESPONSE) {
            const errMsg = streamMessage;
            const res = streamr_client_protocol_1.GroupKeyErrorResponse.fromArray(errMsg.getParsedContent());
            const err = new streamr_client_protocol_1.StreamMessageError(`GroupKeyErrorResponse: ${res.errorMessage}`, streamMessage, res.errorCode);
            throw err;
        }
    })
        // validate
        .forEach(async (streamMessage) => {
        await validate.validate(streamMessage);
    })
        // decrypt
        .forEach(decrypt.decrypt)
        // parse content
        .forEach(async (streamMessage) => {
        streamMessage.getParsedContent();
    })
        // re-order messages (ignore gaps)
        .pipe(orderMessages.transform())
        // ignore any failed messages
        .filter(async (streamMessage) => {
        return !ignoreMessages.has(streamMessage);
    })
        .onBeforeFinally(async () => {
        const tasks = [
            orderMessages.stop(),
            gapFillMessages.stop(),
            decrypt.stop(),
            validate.stop(),
        ];
        await Promise.allSettled(tasks);
    });
}
exports.default = SubscribePipeline;
//# sourceMappingURL=SubscribePipeline.js.map