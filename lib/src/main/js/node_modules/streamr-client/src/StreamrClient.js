"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dependencies = exports.StreamrClient = exports.initContainer = void 0;
require("reflect-metadata");
require("./utils/PatchTsyringe");
const tsyringe_1 = require("tsyringe");
const Ethereum_1 = __importDefault(require("./Ethereum"));
const utils_1 = require("./utils");
const log_1 = require("./utils/log");
const Context_1 = require("./utils/Context");
const Config_1 = __importStar(require("./Config"));
const Container_1 = require("./Container");
const Publisher_1 = __importDefault(require("./publish/Publisher"));
const Subscriber_1 = __importDefault(require("./subscribe/Subscriber"));
const Resends_1 = __importDefault(require("./subscribe/Resends"));
const ResendSubscription_1 = require("./subscribe/ResendSubscription");
const BrubeckNode_1 = __importDefault(require("./BrubeckNode"));
const Session_1 = __importDefault(require("./Session"));
const DestroySignal_1 = require("./DestroySignal");
const StreamEndpoints_1 = require("./StreamEndpoints");
const StreamEndpointsCached_1 = require("./StreamEndpointsCached");
const LoginEndpoints_1 = require("./LoginEndpoints");
const dataunion_1 = __importDefault(require("./dataunion"));
const GroupKeyStoreFactory_1 = __importDefault(require("./encryption/GroupKeyStoreFactory"));
const StorageNodeRegistry_1 = require("./StorageNodeRegistry");
const StreamRegistry_1 = require("./StreamRegistry");
const Plugin_1 = require("./utils/Plugin");
const StreamIDBuilder_1 = require("./StreamIDBuilder");
let uid = process.pid != null
    // Use process id in node uid.
    ? `${process.pid}`
    // Fall back to `uuid()` later (see initContainer). Doing it here will break browser projects
    // that utilize server-side rendering (no `window` while build's target is `web`).
    : '';
let StreamrClientBase = class StreamrClientBase {
    constructor(container, context, options, node, ethereum, session, loginEndpoints, streamEndpoints, cached, resends, publisher, subscriber, groupKeyStore, destroySignal, dataunions, streamRegistry, storageNodeRegistry, streamIdBuilder) {
        this.container = container;
        this.context = context;
        this.options = options;
        this.node = node;
        this.ethereum = ethereum;
        this.session = session;
        this.loginEndpoints = loginEndpoints;
        this.streamEndpoints = streamEndpoints;
        this.cached = cached;
        this.resends = resends;
        this.publisher = publisher;
        this.subscriber = subscriber;
        this.groupKeyStore = groupKeyStore;
        this.destroySignal = destroySignal;
        this.dataunions = dataunions;
        this.streamRegistry = streamRegistry;
        this.storageNodeRegistry = storageNodeRegistry;
        this.streamIdBuilder = streamIdBuilder;
        this.connect = (0, utils_1.pOnce)(async () => {
            await this.node.startNode();
            const tasks = [
                this.publisher.start(),
            ];
            await Promise.allSettled(tasks);
            await Promise.all(tasks);
        });
        this.destroy = (0, utils_1.pOnce)(async () => {
            this.connect.reset(); // reset connect (will error on next call)
            const tasks = [
                this.destroySignal.destroy().then(() => undefined),
                this.resends.stop(),
                this.publisher.stop(),
                this.subscriber.stop(),
            ];
            await Promise.allSettled(tasks);
            await Promise.all(tasks);
        });
        this.id = context.id;
        this.debug = context.debug;
        (0, Plugin_1.Plugin)(this, this.loginEndpoints);
        (0, Plugin_1.Plugin)(this, this.streamEndpoints);
        (0, Plugin_1.Plugin)(this, this.ethereum);
        (0, Plugin_1.Plugin)(this, this.publisher);
        (0, Plugin_1.Plugin)(this, this.subscriber);
        (0, Plugin_1.Plugin)(this, this.resends);
        (0, Plugin_1.Plugin)(this, this.session);
        (0, Plugin_1.Plugin)(this, this.node);
        (0, Plugin_1.Plugin)(this, this.groupKeyStore);
        (0, Plugin_1.Plugin)(this, this.dataunions);
        (0, Plugin_1.Plugin)(this, this.streamRegistry);
        (0, Plugin_1.Plugin)(this, this.storageNodeRegistry);
        this.onDestroy = this.destroySignal.onDestroy.bind(this.destroySignal);
        this.isDestroyed = this.destroySignal.isDestroyed.bind(this.destroySignal);
    }
    subscribe(options, onMessage) {
        if (options.resend !== undefined) {
            return this.resendSubscribe(options, options.resend, onMessage);
        }
        return this.subscriber.subscribe(options, onMessage);
    }
    async resendSubscribe(streamDefinition, resendOptions, onMessage) {
        const streamPartId = await this.streamIdBuilder.toStreamPartID(streamDefinition);
        const subSession = this.subscriber.getOrCreateSubscriptionSession(streamPartId);
        const sub = new ResendSubscription_1.ResendSubscription(subSession, this.resends, resendOptions, this.container);
        if (onMessage) {
            sub.useLegacyOnMessageHandler(onMessage);
        }
        await this.subscriber.addSubscription(sub);
        return sub;
    }
    /** @deprecated */
    disconnect() {
        return this.destroy();
    }
    enableDebugLogging(prefix = 'Streamr*') {
        log_1.Debug.enable(prefix);
    }
    disableDebugLogging() {
        log_1.Debug.disable();
    }
};
StreamrClientBase.generateEthereumAccount = Ethereum_1.default.generateEthereumAccount.bind(Ethereum_1.default);
StreamrClientBase = __decorate([
    __param(2, (0, tsyringe_1.inject)(Config_1.Config.Root)),
    __metadata("design:paramtypes", [Object, Context_1.Context, Object, BrubeckNode_1.default,
        Ethereum_1.default,
        Session_1.default,
        LoginEndpoints_1.LoginEndpoints,
        StreamEndpoints_1.StreamEndpoints,
        StreamEndpointsCached_1.StreamEndpointsCached,
        Resends_1.default,
        Publisher_1.default,
        Subscriber_1.default,
        GroupKeyStoreFactory_1.default,
        DestroySignal_1.DestroySignal,
        dataunion_1.default,
        StreamRegistry_1.StreamRegistry,
        StorageNodeRegistry_1.StorageNodeRegistry,
        StreamIDBuilder_1.StreamIDBuilder])
], StreamrClientBase);
/**
 * @internal
 */
function initContainer(options = {}, parentContainer = tsyringe_1.container) {
    const c = parentContainer.createChildContainer();
    const config = (0, Config_1.default)(options);
    uid = uid || `${(0, utils_1.uuid)().slice(-4)}${(0, utils_1.uuid)().slice(0, 4)}`;
    const id = (0, utils_1.counterId)(`StreamrClient:${uid}${config.id ? `:${config.id}` : ''}`);
    const debug = (0, log_1.Debug)(id);
    // @ts-expect-error not in types
    if (!debug.inspectOpts) {
        // @ts-expect-error not in types
        debug.inspectOpts = {};
    }
    // @ts-expect-error not in types
    Object.assign(debug.inspectOpts, {
        // @ts-expect-error not in types
        ...debug.inspectOpts,
        ...config.debug.inspectOpts
    });
    debug('create');
    const rootContext = {
        id,
        debug
    };
    c.register(Context_1.Context, {
        useValue: rootContext
    });
    c.register(Container_1.BrubeckContainer, {
        useValue: c
    });
    // associate values to config tokens
    const configTokens = [
        [Config_1.Config.Root, config],
        [Config_1.Config.Auth, config.auth],
        [Config_1.Config.Ethereum, config],
        [Config_1.Config.Network, config.network],
        [Config_1.Config.Connection, config],
        [Config_1.Config.Subscribe, config],
        [Config_1.Config.Publish, config],
        [Config_1.Config.Encryption, config],
        [Config_1.Config.Cache, config.cache],
    ];
    configTokens.forEach(([token, useValue]) => {
        c.register(token, { useValue });
    });
    return {
        config,
        childContainer: c,
        rootContext,
    };
}
exports.initContainer = initContainer;
class StreamrClient extends StreamrClientBase {
    constructor(options = {}, parentContainer = tsyringe_1.container) {
        const { childContainer: c, config } = initContainer(options, parentContainer);
        super(c, c.resolve(Context_1.Context), config, c.resolve(BrubeckNode_1.default), c.resolve(Ethereum_1.default), c.resolve(Session_1.default), c.resolve(LoginEndpoints_1.LoginEndpoints), c.resolve(StreamEndpoints_1.StreamEndpoints), c.resolve(StreamEndpointsCached_1.StreamEndpointsCached), c.resolve(Resends_1.default), c.resolve(Publisher_1.default), c.resolve(Subscriber_1.default), c.resolve(GroupKeyStoreFactory_1.default), c.resolve(DestroySignal_1.DestroySignal), c.resolve(dataunion_1.default), c.resolve(StreamRegistry_1.StreamRegistry), c.resolve(StorageNodeRegistry_1.StorageNodeRegistry), c.resolve(StreamIDBuilder_1.StreamIDBuilder));
    }
}
exports.StreamrClient = StreamrClient;
exports.Dependencies = {
    Context: Context_1.Context,
    BrubeckNode: BrubeckNode_1.default,
    StorageNodeRegistry: StorageNodeRegistry_1.StorageNodeRegistry,
    Session: Session_1.default,
    LoginEndpoints: LoginEndpoints_1.LoginEndpoints,
    StreamEndpoints: StreamEndpoints_1.StreamEndpoints,
    StreamEndpointsCached: StreamEndpointsCached_1.StreamEndpointsCached,
    Resends: Resends_1.default,
    Publisher: Publisher_1.default,
    Subscriber: Subscriber_1.default,
    GroupKeyStoreFactory: GroupKeyStoreFactory_1.default,
    DestroySignal: DestroySignal_1.DestroySignal,
    DataUnions: dataunion_1.default,
};
//# sourceMappingURL=StreamrClient.js.map