/// <reference types="node" />
import EventEmitter from 'events';
import { MaybeAsync } from '../types';
import AggregatedError from './AggregatedError';
import Scaffold from './Scaffold';
export declare const debug: import("debug").Debugger;
export { default as uuid } from './uuid';
export { AggregatedError, Scaffold };
export declare function randomString(length?: number): string;
/**
 * Generates counter-based ids.
 * Basically lodash.uniqueid but per-prefix.
 * Not universally unique.
 * Generally useful for tracking instances.
 *
 * Careful not to use too many prefixes since it needs to hold all prefixes in memory
 * e.g. don't pass new uuid as a prefix
 *
 * counterId('test') => test.0
 * counterId('test') => test.1
 */
export declare const CounterId: (rootPrefix?: string | undefined, { maxPrefixes }?: {
    maxPrefixes?: number | undefined;
}) => {
    (prefix?: string, separator?: string): string;
    /**
     * Clears counts for prefix or all if no prefix supplied.
     *
     * @param {string?} prefix
     */
    clear(...args: [string] | []): void;
};
export declare const counterId: {
    (prefix?: string, separator?: string): string;
    /**
     * Clears counts for prefix or all if no prefix supplied.
     *
     * @param {string?} prefix
     */
    clear(...args: [string] | []): void;
};
export declare type AnyInstance = {
    constructor: {
        name: string;
        prototype: null | AnyInstance;
    };
};
export declare function instanceId(instance: AnyInstance, suffix?: string): string;
export declare function getVersionString(): string;
/**
 * Converts a .once event listener into a promise.
 * Rejects if an 'error' event is received before resolving.
 */
export declare function waitFor(emitter: EventEmitter, event: Parameters<EventEmitter['on']>[0]): Promise<unknown>;
export declare const getEndpointUrl: (baseUrl: string, ...pathParts: string[]) => string;
/**
 * Returns a cached async fn, cached keyed on first argument passed. See documentation for mem/p-memoize.
 * Caches into a LRU cache capped at options.maxSize
 * Won't call asyncFn again until options.maxAge or options.maxSize exceeded, or cachedAsyncFn.clear() is called.
 * Won't cache rejections by default. Override with options.cachePromiseRejection = true.
 *
 * ```js
 * const cachedAsyncFn = CacheAsyncFn(asyncFn, options)
 * await cachedAsyncFn(key)
 * await cachedAsyncFn(key)
 * cachedAsyncFn.clear()
 * ```
 */
export declare function CacheAsyncFn<ArgsType extends any[], ReturnType, KeyType = ArgsType[0]>(asyncFn: (...args: ArgsType) => PromiseLike<ReturnType>, { maxSize, maxAge, // 30 minutes
cachePromiseRejection, onEviction, cacheKey, // type+provide default so we can infer KeyType
...opts }?: {
    maxSize?: number;
    maxAge?: number;
    cachePromiseRejection?: boolean;
    onEviction?: (...args: any[]) => void;
    cacheKey?: (args: ArgsType) => KeyType;
}): ((...args: ArgsType) => Promise<ReturnType>) & {
    clear: () => void;
    clearMatching: (matchFn: (key: KeyType) => boolean) => void;
};
/**
 * Returns a cached fn, cached keyed on first argument passed. See documentation for mem.
 * Caches into a LRU cache capped at options.maxSize
 * Won't call fn again until options.maxAge or options.maxSize exceeded, or cachedFn.clear() is called.
 *
 * ```js
 * const cachedFn = CacheFn(fn, options)
 * cachedFn(key)
 * cachedFn(key)
 * cachedFn(...args)
 * cachedFn.clear()
 * ```
 */
export declare function CacheFn<ArgsType extends any[], ReturnType, KeyType = ArgsType[0]>(fn: (...args: ArgsType) => ReturnType, { maxSize, maxAge, // 30 minutes
onEviction, cacheKey, // type+provide default so we can infer KeyType
...opts }?: {
    maxSize?: number;
    maxAge?: number;
    onEviction?: (...args: any[]) => void;
    cacheKey?: (args: ArgsType) => KeyType;
}): ((...args: ArgsType) => ReturnType) & {
    clear: () => void;
    clearMatching: (matchFn: (key: KeyType) => boolean) => void;
};
declare class DeferredWrapper<T> {
    wrap(...args: any[]): Promise<T> & {
        resolve: (value: any) => unknown;
        reject: (reason: any) => unknown;
        wrap: <ArgsType extends any[], ReturnType_1>(fn: (...args: ArgsType) => ReturnType_1) => (...args: ArgsType) => Promise<unknown>;
        wrapError: <ArgsType_1 extends any[], ReturnType_2>(fn: (...args: ArgsType_1) => ReturnType_2) => (...args: ArgsType_1) => Promise<ReturnType_2>;
        handleErrBack: (err?: Error | undefined) => void;
        isResolved(): boolean;
    };
}
export declare type Deferred<T> = ReturnType<DeferredWrapper<T>['wrap']>;
export declare function Defer<T>(executor?: (...args: Parameters<Promise<T>['then']>) => void): Promise<T> & {
    resolve: (value: any) => unknown;
    reject: (reason: any) => unknown;
    wrap: <ArgsType extends any[], ReturnType_1>(fn: (...args: ArgsType) => ReturnType_1) => (...args: ArgsType) => Promise<unknown>;
    wrapError: <ArgsType_1 extends any[], ReturnType_2>(fn: (...args: ArgsType_1) => ReturnType_2) => (...args: ArgsType_1) => Promise<ReturnType_2>;
    handleErrBack: (err?: Error | undefined) => void;
    isResolved(): boolean;
};
export declare function LimitAsyncFnByKey<KeyType>(limit?: number): {
    (id: KeyType, fn: () => Promise<any>): Promise<any>;
    getActiveCount(id: KeyType): number;
    getPendingCount(id: KeyType): number;
    clear(): void;
};
/**
 * Execute functions in parallel, but ensure they resolve in the order they were executed
 */
export declare function pOrderedResolve<ArgsType extends unknown[], ReturnType>(fn: (...args: ArgsType) => ReturnType): ((...args: ArgsType) => Promise<ReturnType>) & {
    clear(): void;
};
/**
 * Returns a function that executes with limited concurrency.
 */
export declare function pLimitFn<ArgsType extends unknown[], ReturnType>(fn: (...args: ArgsType) => ReturnType | Promise<ReturnType>, limit?: number): ((...args: ArgsType) => Promise<ReturnType>) & {
    clear(): void;
};
/**
 * Only allows one outstanding call.
 * Returns same promise while task is executing.
 */
export declare function pOne<ArgsType extends unknown[], ReturnType>(fn: (...args: ArgsType) => ReturnType | Promise<ReturnType>): ((...args: ArgsType) => Promise<ReturnType>);
/**
 * Only allows calling `fn` once.
 * Returns same promise while task is executing.
 */
export declare function pOnce<ArgsType extends unknown[], ReturnType>(fn: (...args: ArgsType) => ReturnType | Promise<ReturnType>): ((...args: ArgsType) => Promise<ReturnType>) & {
    reset(): void;
    isStarted(): boolean;
};
export declare class TimeoutError extends Error {
    timeout: number;
    constructor(msg?: string, timeout?: number);
}
/**
 * Takes a promise and a timeout and an optional message for timeout errors.
 * Returns a promise that rejects when timeout expires, or when promise settles, whichever comes first.
 *
 * Invoke with positional arguments for timeout & message:
 * await pTimeout(promise, timeout, message)
 *
 * or using an options object for timeout, message & rejectOnTimeout:
 *
 * await pTimeout(promise, { timeout, message, rejectOnTimeout })
 *
 * message and rejectOnTimeout are optional.
 */
declare type pTimeoutOpts = {
    timeout?: number;
    message?: string;
    rejectOnTimeout?: boolean;
};
declare type pTimeoutArgs = [timeout?: number, message?: string] | [pTimeoutOpts];
export declare function pTimeout<T>(promise: Promise<T>, ...args: pTimeoutArgs): Promise<T | undefined>;
/**
 * Convert allSettled results into a thrown Aggregate error if necessary.
 */
export declare function allSettledValues(items: Parameters<(typeof Promise)['allSettled']>[0], errorMessage?: string): Promise<unknown[]>;
export declare function sleep(ms?: number): Promise<unknown>;
/**
 * Wait until a condition is true
 * @param condition - wait until this callback function returns true
 * @param timeOutMs - stop waiting after that many milliseconds, -1 for disable
 * @param pollingIntervalMs - check condition between so many milliseconds
 * @param failedMsgFn - append the string return value of this getter function to the error message, if given
 * @return the (last) truthy value returned by the condition function
 */
export declare function until(condition: MaybeAsync<() => boolean>, timeOutMs?: number, pollingIntervalMs?: number, failedMsgFn?: () => string): Promise<boolean>;
