import { StreamMessage, GroupKeyRequest, GroupKeyResponse, GroupKeyErrorResponse } from 'streamr-client-protocol';
import { Context } from '../utils/Context';
import { DestroySignal } from '../DestroySignal';
import Subscriber from '../subscribe/Subscriber';
import Publisher from '../publish/Publisher';
import { Subscription } from '../subscribe/Subscription';
import Ethereum from '../Ethereum';
import { Stoppable } from '../utils/Stoppable';
import { GroupKey, GroupKeyish } from './Encryption';
export declare type GroupKeyId = string;
export declare type GroupKeysSerialized = Record<GroupKeyId, GroupKeyish>;
export declare type EncryptionConfig = {
    groupKeys: Record<string, GroupKeysSerialized>;
};
export declare function parseGroupKeys(groupKeys?: GroupKeysSerialized): Map<GroupKeyId, GroupKey>;
export declare class KeyExchangeStream implements Context, Stoppable {
    private ethereum;
    private subscriber;
    private destroySignal;
    private publisher;
    id: string;
    debug: import("debug").Debugger;
    subscribe: (() => Promise<Subscription<unknown>>) & {
        reset(): void;
    };
    isStopped: boolean;
    constructor(context: Context, ethereum: Ethereum, subscriber: Subscriber, destroySignal: DestroySignal, publisher: Publisher);
    private createSubscription;
    stop(): void;
    request(publisherId: string, request: GroupKeyRequest): Promise<StreamMessage<unknown> | undefined>;
    response(subscriberId: string, response: GroupKeyResponse | GroupKeyErrorResponse): Promise<StreamMessage<GroupKeyResponse | GroupKeyErrorResponse> | undefined>;
}
