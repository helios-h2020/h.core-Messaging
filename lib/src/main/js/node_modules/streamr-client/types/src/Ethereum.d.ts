import type { ExternalProvider, Provider } from '@ethersproject/providers';
import type { Signer } from '@ethersproject/abstract-signer';
import type { BigNumber } from '@ethersproject/bignumber';
import type { ConnectionInfo } from '@ethersproject/web';
import type { Overrides } from '@ethersproject/contracts';
import { EthereumAddress } from 'streamr-client-protocol';
declare type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
declare type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
declare type ChainConnectionInfo = {
    rpcs: ConnectionInfo[];
    chainId?: number;
    name?: string;
};
export declare type ProviderConfig = ExternalProvider;
export declare type ProviderAuthConfig = {
    ethereum: ProviderConfig;
};
export declare type PrivateKeyAuthConfig = {
    privateKey: string;
    address?: string;
};
export declare type SessionTokenAuthConfig = {
    sessionToken: string;
};
export declare type APIKeyAuthConfig = {
    apiKey: string;
};
export declare type UsernamePasswordAuthConfig = {
    username: string;
    password: string;
};
export declare type UnauthenticatedAuthConfig = XOR<{}, {
    unauthenticated: true;
}>;
export declare type DeprecatedAuthConfig = XOR<APIKeyAuthConfig, UsernamePasswordAuthConfig>;
export declare type AuthenticatedConfig = XOR<ProviderAuthConfig, PrivateKeyAuthConfig> & Partial<SessionTokenAuthConfig>;
export declare type AuthConfig = XOR<AuthenticatedConfig, UnauthenticatedAuthConfig>;
export declare type AllAuthConfig = XOR<AuthConfig, DeprecatedAuthConfig>;
declare type EthereumNetworkConfig = {
    chainId: number;
    overrides?: Overrides;
    gasPriceStrategy?: (estimatedGasPrice: BigNumber) => BigNumber;
};
export declare abstract class EthereumConfig {
    abstract dataUnionBinanceWithdrawalChainRPCs: ChainConnectionInfo;
    abstract binanceAdapterAddress: EthereumAddress;
    abstract binanceSmartChainAMBAddress: EthereumAddress;
    abstract withdrawServerUrl: string;
    abstract mainChainRPCs?: ChainConnectionInfo;
    abstract dataUnionChainRPCs: ChainConnectionInfo;
    abstract tokenAddress: EthereumAddress;
    abstract tokenSidechainAddress: EthereumAddress;
    abstract streamRegistryChainRPCs: ChainConnectionInfo;
    abstract ethereumNetworks?: {
        [networkName: string]: EthereumNetworkConfig;
    };
}
declare class StreamrEthereum {
    private ethereumConfig;
    static generateEthereumAccount(): {
        address: string;
        privateKey: string;
    };
    _getAddress?: () => Promise<string>;
    _getSigner?: () => Signer;
    _getDataUnionChainSigner?: () => Promise<Signer>;
    _getStreamRegistryChainSigner?: () => Promise<Signer>;
    constructor(authConfig: AllAuthConfig, ethereumConfig: EthereumConfig);
    isAuthenticated(): boolean;
    canEncrypt(): boolean;
    getAddress(): Promise<string>;
    getSigner(): Signer;
    getDataUnionChainSigner(): Promise<Signer>;
    getStreamRegistryChainSigner(): Promise<Signer>;
    /** @returns Ethers.js Provider, a connection to the Ethereum network (mainnet) */
    getMainnetProvider(): Provider;
    /** @returns Array of Ethers.js Providers, connections to the Ethereum network (mainnet) */
    getAllMainnetProviders(): Provider[];
    /** @returns Ethers.js Provider, a connection to the Binance Smart Chain */
    getBinanceProvider(): Provider;
    /** @returns Array of Ethers.js Provider, connections to Binance Smart Chain */
    getAllBinanceProviders(): Provider[];
    /** @returns Ethers.js Provider, a connection to the Streamr EVM sidechain */
    getDataUnionChainProvider(): Provider;
    /** @returns Array of Ethers.js Provider, connections to the Streamr EVM sidechain */
    getAllDataUnionChainProviders(): Provider[];
    /** @returns Ethers.js Provider, a connection to the Stream Registry Chain */
    getStreamRegistryChainProvider(): Provider;
    /** @returns Array of Ethers.js Providers, connections to the Stream Registry Chain */
    getAllStreamRegistryChainProviders(): Provider[];
    getMainnetOverrides(): Overrides;
    getBinanceOverrides(): Overrides;
    getDataUnionOverrides(): Overrides;
    getStreamRegistryOverrides(): Overrides;
    /**
     * Apply the gasPriceStrategy to the estimated gas price, if given
     * Ethers.js will resolve the gas price promise before sending the tx
     */
    private getOverrides;
}
export default StreamrEthereum;
