import { DependencyContainer } from 'tsyringe';
import { ContentType, EncryptionType, SignatureType, StreamMessageType, EthereumAddress, StreamPartID } from 'streamr-client-protocol';
import { Context } from './utils/Context';
import { Stream } from './Stream';
import { ConnectionConfig } from './Config';
import { Rest } from './Rest';
import StreamrEthereum from './Ethereum';
import { StreamRegistry } from './StreamRegistry';
import { StorageNodeRegistry } from './StorageNodeRegistry';
import { StreamIDBuilder } from './StreamIDBuilder';
import { StreamDefinition } from './types';
export interface StreamValidationInfo {
    id: string;
    partitions: number;
    requireSignedData: boolean;
    storageDays: number;
}
export interface StreamMessageAsObject {
    streamId: string;
    streamPartition: number;
    timestamp: number;
    sequenceNumber: number;
    publisherId: string;
    msgChainId: string;
    messageType: StreamMessageType;
    contentType: ContentType;
    encryptionType: EncryptionType;
    groupKeyId: string | null;
    content: any;
    signatureType: SignatureType;
    signature: string | null;
}
/** TODO the class should be annotated with at-internal, but adding the annotation hides the methods */
export declare class StreamEndpoints implements Context {
    private container;
    private readonly options;
    private readonly rest;
    private readonly storageNodeRegistry;
    private readonly streamRegistry;
    private readonly streamIdBuilder;
    private readonly ethereum;
    id: string;
    debug: import("debug").Debugger;
    constructor(context: Context, container: DependencyContainer, options: ConnectionConfig, rest: Rest, storageNodeRegistry: StorageNodeRegistry, streamRegistry: StreamRegistry, streamIdBuilder: StreamIDBuilder, ethereum: StreamrEthereum);
    /**
     * @category Important
     */
    getOrCreateStream(props: {
        id: string;
        partitions?: number;
    }): Promise<Stream>;
    getStreamLast(streamDefinition: StreamDefinition, count?: number): Promise<StreamMessageAsObject[]>;
    getStreamPartsByStorageNode(nodeAddress: EthereumAddress): Promise<StreamPartID[]>;
    publishHttp(nodeUrl: string, streamIdOrPath: string, data: any, requestOptions?: any, keepAlive?: boolean): Promise<void>;
}
