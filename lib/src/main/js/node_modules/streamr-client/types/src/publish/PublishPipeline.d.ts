/**
 * Organises async Publish steps into a Pipeline
 */
import { StreamMessage } from 'streamr-client-protocol';
import { Deferred } from '../utils';
import { Context } from '../utils/Context';
import { PushPipeline, Pipeline } from '../utils/Pipeline';
import { Stoppable } from '../utils/Stoppable';
import StreamMessageCreator from './MessageCreator';
import BrubeckNode from '../BrubeckNode';
import Signer from './Signer';
import Encrypt from './Encrypt';
import Validator from '../Validator';
import { DestroySignal } from '../DestroySignal';
import { StreamIDBuilder } from '../StreamIDBuilder';
import { StreamDefinition } from '../types';
export declare class FailedToPublishError extends Error {
    publishMetadata: PublishMetadataStrict<unknown>;
    reason: Error | undefined;
    constructor(publishMetadata: PublishMetadataStrict, reason?: Error);
}
export declare type PublishMetadata<T = unknown> = {
    content: T;
    timestamp?: string | number | Date;
    sequenceNumber?: number;
    partitionKey?: string | number;
};
export declare type PublishMetadataStrict<T = unknown> = PublishMetadata<T> & {
    timestamp: number;
    streamDefinition: StreamDefinition;
    partitionKey?: number | string;
};
export declare type PublishQueueIn<T = unknown> = [PublishMetadataStrict<T>, Deferred<StreamMessage<T>>];
export declare type PublishQueueOut<T = unknown> = [StreamMessage<T>, Deferred<StreamMessage<T>>];
export default class PublishPipeline implements Context, Stoppable {
    private node;
    private messageCreator;
    private signer;
    private validator;
    private destroySignal;
    private streamIdBuilder;
    private encryption;
    id: string;
    debug: import("debug").Debugger;
    /** takes metadata & creates stream messages. unsigned, unencrypted */
    streamMessageQueue: PushPipeline<PublishQueueIn, PublishQueueOut>;
    /** signs, encrypts then publishes messages */
    publishQueue: Pipeline<PublishQueueOut, PublishQueueOut>;
    isStarted: boolean;
    isStopped: boolean;
    inProgress: Set<Promise<StreamMessage<unknown>> & {
        resolve: (value: any) => unknown;
        reject: (reason: any) => unknown;
        wrap: <ArgsType extends any[], ReturnType_1>(fn: (...args: ArgsType) => ReturnType_1) => (...args: ArgsType) => Promise<unknown>;
        wrapError: <ArgsType_1 extends any[], ReturnType_2>(fn: (...args: ArgsType_1) => ReturnType_2) => (...args: ArgsType_1) => Promise<ReturnType_2>;
        handleErrBack: (err?: Error | undefined) => void;
        isResolved(): boolean;
    }>;
    constructor(context: Context, node: BrubeckNode, messageCreator: StreamMessageCreator, signer: Signer, validator: Validator, destroySignal: DestroySignal, streamIdBuilder: StreamIDBuilder, encryption: Encrypt);
    private filterResolved;
    private toStreamMessage;
    private encryptMessage;
    private signMessage;
    private validateMessage;
    private consumeQueue;
    /**
     * Starts queue if not already started.
     */
    private startQueue;
    check(): void;
    /**
     * Put publish metadata into queue to be published.
     * Creates a Defer to be resolved when message gets sent to node.
     */
    publish<T>(publishMetadata: PublishMetadataStrict<T>): Promise<StreamMessage<T>>;
    start(): void;
    stop(): Promise<void>;
}
