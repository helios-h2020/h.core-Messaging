import { IPushBuffer, PushBuffer, PushBufferOptions } from './PushBuffer';
import { Context } from './Context';
import * as G from './GeneratorUtils';
import Signal from './Signal';
export declare type PipelineTransform<InType = any, OutType = any> = (src: AsyncGenerator<InType>) => AsyncGenerator<OutType>;
export declare type FinallyFn = ((err?: Error) => void | Promise<void>);
declare type AsyncGeneratorWithId<T> = AsyncGenerator<T> & {
    id: string;
};
/**
 * Pipeline public interface
 */
export declare type IPipeline<InType, OutType = InType> = {
    pipe<NewOutType>(fn: PipelineTransform<OutType, NewOutType>): IPipeline<InType, NewOutType>;
    map<NewOutType>(fn: G.GeneratorMap<OutType, NewOutType>): IPipeline<InType, NewOutType>;
    mapBefore(fn: G.GeneratorMap<InType, InType>): IPipeline<InType, OutType>;
    filter(fn: G.GeneratorFilter<OutType>): IPipeline<InType, OutType>;
    forEach(fn: G.GeneratorForEach<OutType>): IPipeline<InType, OutType>;
    forEachBefore(fn: G.GeneratorForEach<InType>): IPipeline<InType, OutType>;
    filterBefore(fn: G.GeneratorForEach<InType>): IPipeline<InType, OutType>;
    collect(n?: number): Promise<OutType[]>;
    consume(): Promise<void>;
    pipeBefore(fn: PipelineTransform<InType, InType>): IPipeline<InType, OutType>;
} & AsyncGenerator<OutType> & Context;
declare class PipelineDefinition<InType, OutType = InType> {
    protected transforms: PipelineTransform[];
    protected transformsBefore: PipelineTransform[];
    id: string;
    debug: import("debug").Debugger;
    source: AsyncGeneratorWithId<InType>;
    constructor(context: Context, source: AsyncGenerator<InType>, transforms?: PipelineTransform[], transformsBefore?: PipelineTransform[]);
    /**
     * Append a transformation step to this pipeline.
     * Changes the pipeline's output type to output type of this generator.
     */
    pipe<NewOutType>(fn: PipelineTransform<OutType, NewOutType>): PipelineDefinition<InType, NewOutType>;
    /**
     * Inject pipeline step before other transforms.
     * Note must return same type as source, otherwise we can't be type-safe.
     */
    pipeBefore(fn: PipelineTransform<InType, InType>): PipelineDefinition<InType, OutType>;
    clearTransforms(): void;
    setSource(source: AsyncGenerator<InType> | AsyncGeneratorWithId<InType>): AsyncGeneratorWithId<InType>;
    getTransforms(): PipelineTransform<any, any>[];
}
export declare class Pipeline<InType, OutType = InType> implements IPipeline<InType, OutType> {
    source: AsyncGenerator<InType>;
    debug: import("debug").Debugger;
    id: string;
    protected iterator: AsyncGenerator<OutType>;
    isIterating: boolean;
    isCleaningUp: boolean;
    definition: PipelineDefinition<InType, OutType>;
    constructor(source: AsyncGenerator<InType>, definition?: PipelineDefinition<InType, OutType>);
    /**
     * Append a transformation step to this pipeline.
     * Changes the pipeline's output type to output type of this generator.
     */
    pipe<NewOutType>(fn: PipelineTransform<OutType, NewOutType>): Pipeline<InType, NewOutType>;
    /**
     * Inject pipeline step before other transforms.
     * Note must return same type as source, otherwise we can't be type-safe.
     */
    pipeBefore(fn: PipelineTransform<InType, InType>): Pipeline<InType, OutType>;
    /**
     * Fires this callback the moment this part of the pipeline starts returning.
     */
    onConsumed(fn: () => void | Promise<void>): Pipeline<InType, Awaited<OutType>>;
    /**
     * Triggers once when pipeline ends.
     * Usage: `pipeline.onFinally(callback)`
     */
    onFinally: {
        (): Promise<void | Error>;
        <ReturnType_1>(this: ReturnType_1, cb: (args_0: void | Error) => unknown): ReturnType_1;
    } & import("./Plugin").Methods<Signal<[void | Error]>>;
    /**
     * Triggers once when pipeline is about to end.
     */
    onBeforeFinally: {
        (): Promise<undefined>;
        <ReturnType_1>(this: ReturnType_1, cb: () => unknown): ReturnType_1;
    } & import("./Plugin").Methods<Signal<[]>>;
    /**
     * Triggers once when pipeline starts flowing.
     * Usage: `pipeline.onStart(callback)`
     */
    onStart: {
        (): Promise<undefined>;
        <ReturnType_1>(this: ReturnType_1, cb: () => unknown): ReturnType_1;
    } & import("./Plugin").Methods<Signal<[]>>;
    onMessage: {
        (): Promise<OutType>;
        <ReturnType_1>(this: ReturnType_1, cb: (args_0: OutType) => unknown): ReturnType_1;
    } & import("./Plugin").Methods<Signal<[OutType]>>;
    onError: {
        (): Promise<Error>;
        <ReturnType_1>(this: ReturnType_1, cb: (args_0: Error, args_1?: InType | OutType | undefined, args_2?: number | undefined) => unknown): ReturnType_1;
    } & import("./Plugin").Methods<Signal<[Error, (InType | OutType | undefined)?, (number | undefined)?]>>;
    map<NewOutType>(fn: G.GeneratorMap<OutType, NewOutType>): Pipeline<InType, NewOutType>;
    mapBefore(fn: G.GeneratorMap<InType, InType>): Pipeline<InType, OutType>;
    forEach(fn: G.GeneratorForEach<OutType>): Pipeline<InType, OutType>;
    filter(fn: G.GeneratorFilter<OutType>): Pipeline<InType, OutType>;
    reduce<NewOutType>(fn: G.GeneratorReduce<OutType, NewOutType>, initialValue: NewOutType): Pipeline<InType, NewOutType>;
    forEachBefore(fn: G.GeneratorForEach<InType>): Pipeline<InType, OutType>;
    filterBefore(fn: G.GeneratorFilter<InType>): Pipeline<InType, OutType>;
    consume(fn?: G.GeneratorForEach<OutType>): Promise<void>;
    collect(n?: number): Promise<OutType[]>;
    flow(): this;
    private cleanup;
    handleError(err: Error): Promise<void>;
    private iterate;
    throw(err: Error): Promise<IteratorResult<OutType, any>>;
    return(v?: OutType): Promise<IteratorResult<OutType, any>>;
    next(): Promise<IteratorResult<OutType, any>>;
    /**
     * Create a new Pipeline forked from this pipeline.
     * Pushes results into fork.
     * Note: Does not start consuming this pipeline.
     */
    [Symbol.asyncIterator](): this;
}
/**
 * Pipeline that is also a PushBuffer.
 * i.e. can call .push to push data into pipeline and .pipe to transform it.
 */
export declare class PushPipeline<InType, OutType = InType> extends Pipeline<InType, OutType> implements IPushBuffer<InType, OutType> {
    readonly source: PushBuffer<InType>;
    constructor(bufferSize?: number, options?: PushBufferOptions);
    pipe<NewOutType>(fn: PipelineTransform<OutType, NewOutType>): PushPipeline<InType, NewOutType>;
    map<NewOutType>(fn: G.GeneratorMap<OutType, NewOutType>): PushPipeline<InType, NewOutType>;
    mapBefore(fn: G.GeneratorMap<InType, InType>): PushPipeline<InType, OutType>;
    filterBefore(fn: G.GeneratorFilter<InType>): PushPipeline<InType, OutType>;
    filter(fn: G.GeneratorFilter<OutType>): PushPipeline<InType, OutType>;
    forEach(fn: G.GeneratorForEach<OutType>): PushPipeline<InType, OutType>;
    forEachBefore(fn: G.GeneratorForEach<InType>): PushPipeline<InType, OutType>;
    pull(source: AsyncGenerator<InType>): Promise<void>;
    push(item: InType | Error): Promise<boolean>;
    handleError(err: Error): Promise<void>;
    end(err?: Error): void;
    endWrite(err?: Error): void;
    isDone(): boolean;
    get length(): number;
    isFull(): boolean;
    clear(): void;
}
export {};
