import { OrderingUtil, StreamMessage, StreamPartID, MessageRef } from 'streamr-client-protocol';
import { PushBuffer } from '../utils/PushBuffer';
import { Context } from '../utils/Context';
import Signal from '../utils/Signal';
import Resends from './Resends';
import { MessageStream } from './MessageStream';
import { SubscribeConfig } from '../Config';
/**
 * Wraps OrderingUtil into a PushBuffer.
 * Implements gap filling
 */
export default class OrderMessages<T> implements Context {
    private options;
    private resends;
    private readonly streamPartId;
    id: string;
    debug: import("debug").Debugger;
    stopSignal: {
        (): Promise<undefined>;
        <ReturnType_1>(this: ReturnType_1, cb: () => unknown): ReturnType_1;
    } & import("../utils/Plugin").Methods<Signal<[]>>;
    done: boolean;
    resendStreams: Set<MessageStream<T, StreamMessage<T>, StreamMessage<T>>>;
    outBuffer: PushBuffer<StreamMessage<T>>;
    inputClosed: boolean;
    orderMessages: boolean;
    enabled: boolean;
    orderingUtil: OrderingUtil;
    constructor(options: SubscribeConfig, context: Context, resends: Resends, streamPartId: StreamPartID);
    onGap(from: MessageRef, to: MessageRef, publisherId: string, msgChainId: string): Promise<void>;
    onOrdered(orderedMessage: StreamMessage): void;
    stop(): Promise<void>;
    maybeClose(): void;
    addToOrderingUtil(src: AsyncGenerator<StreamMessage<T>>): Promise<void>;
    transform(): (src: AsyncGenerator<StreamMessage<T>, any, unknown>) => AsyncGenerator<StreamMessage<T>, void, unknown>;
}
