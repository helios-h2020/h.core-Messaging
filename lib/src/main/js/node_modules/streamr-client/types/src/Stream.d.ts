export { GroupKey } from './encryption/Encryption';
import { Rest } from './Rest';
import Resends from './subscribe/Resends';
import Publisher from './publish/Publisher';
import { StreamRegistry } from './StreamRegistry';
import Ethereum from './Ethereum';
import { StorageNodeRegistry } from './StorageNodeRegistry';
import { StreamEndpoints } from './StreamEndpoints';
import { StreamEndpointsCached } from './StreamEndpointsCached';
import { EthereumAddress, StreamID, StreamMetadata } from 'streamr-client-protocol';
import { PermissionAssignment, PublicPermissionQuery, UserPermissionQuery } from './permission';
export interface StreamProperties {
    id: string;
    description?: string;
    config?: {
        fields: Field[];
    };
    partitions?: number;
    requireSignedData?: boolean;
    storageDays?: number;
    inactivityThresholdHours?: number;
}
export interface StreamrStreamConstructorOptions extends StreamProperties {
    id: StreamID;
}
declare const VALID_FIELD_TYPES: readonly ["number", "string", "boolean", "list", "map"];
export declare type Field = {
    name: string;
    type: typeof VALID_FIELD_TYPES[number];
};
declare class StreamrStream implements StreamMetadata {
    private _container;
    id: StreamID;
    description?: string;
    config: {
        fields: Field[];
    };
    partitions: number;
    requireSignedData: boolean;
    storageDays?: number;
    inactivityThresholdHours?: number;
    protected _rest: Rest;
    protected _resends: Resends;
    protected _publisher: Publisher;
    protected _streamEndpoints: StreamEndpoints;
    protected _streamEndpointsCached: StreamEndpointsCached;
    protected _streamRegistry: StreamRegistry;
    protected _nodeRegistry: StorageNodeRegistry;
    protected _ethereuem: Ethereum;
    private readonly _httpFetcher;
    private _clientConfig;
    /**
     * Persist stream metadata updates.
     */
    update(): Promise<void>;
    toObject(): StreamProperties;
    delete(): Promise<void>;
    detectFields(): Promise<void>;
    addToStorageNode(nodeAddress: EthereumAddress, waitOptions?: {
        timeout?: number;
        pollInterval?: number;
    }): Promise<void>;
    waitUntilStorageAssigned({ timeout, pollInterval }: {
        timeout?: number | undefined;
        pollInterval?: number | undefined;
    } | undefined, url: string): Promise<void>;
    private isStreamStoredInStorageNode;
    removeFromStorageNode(nodeAddress: EthereumAddress): Promise<void>;
    getStorageNodes(): Promise<string[]>;
    publish<T>(content: T, timestamp?: number | string | Date, partitionKey?: string): Promise<import("streamr-client-protocol").StreamMessage<T>>;
    hasPermission(query: Omit<UserPermissionQuery, 'streamId'> | Omit<PublicPermissionQuery, 'streamId'>): Promise<boolean>;
    getPermissions(): Promise<PermissionAssignment[]>;
    grantPermissions(...assignments: PermissionAssignment[]): Promise<void>;
    revokePermissions(...assignments: PermissionAssignment[]): Promise<void>;
}
export { StreamrStream as Stream };
