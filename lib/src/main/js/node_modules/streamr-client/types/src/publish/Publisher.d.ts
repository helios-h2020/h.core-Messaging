/**
 * Public Publishing API
 */
import { StreamMessage } from 'streamr-client-protocol';
import { Context } from '../utils/Context';
import { StreamEndpoints } from '../StreamEndpoints';
import PublishPipeline, { PublishMetadata } from './PublishPipeline';
import { Stoppable } from '../utils/Stoppable';
import { PublisherKeyExchange } from '../encryption/KeyExchangePublisher';
import Validator from '../Validator';
import BrubeckNode from '../BrubeckNode';
import { StreamIDBuilder } from '../StreamIDBuilder';
import { StreamDefinition } from '../types';
import { StrictStreamrClientConfig } from '../Config';
export type { PublishMetadata };
export default class BrubeckPublisher implements Context, Stoppable {
    private pipeline;
    private node;
    private validator;
    private streamIdBuilder;
    private keyExchange;
    private streamEndpoints;
    private config;
    id: string;
    debug: import("debug").Debugger;
    streamMessageQueue: import("../utils/Pipeline").PushPipeline<import("./PublishPipeline").PublishQueueIn<unknown>, import("./PublishPipeline").PublishQueueOut<unknown>>;
    publishQueue: import("../utils/Pipeline").Pipeline<import("./PublishPipeline").PublishQueueOut<unknown>, import("./PublishPipeline").PublishQueueOut<unknown>>;
    isStopped: boolean;
    private inProgress;
    constructor(context: Context, pipeline: PublishPipeline, node: BrubeckNode, validator: Validator, streamIdBuilder: StreamIDBuilder, keyExchange: PublisherKeyExchange, streamEndpoints: StreamEndpoints, config: StrictStreamrClientConfig);
    validateAndPublishStreamMessage<T>(streamMessage: StreamMessage<T>): Promise<void>;
    publish<T>(streamDefinition: StreamDefinition, content: T, timestamp?: string | number | Date, partitionKey?: string | number): Promise<StreamMessage<T>>;
    publishMessage<T>(streamDefinition: StreamDefinition, { content, timestamp, partitionKey }: PublishMetadata<T>): Promise<StreamMessage<T>>;
    collect<T>(target: AsyncIterable<StreamMessage<T>>, n?: number): Promise<T[]>;
    collectMessages<T>(target: AsyncIterable<T>, n?: number): Promise<Awaited<T>[]>;
    waitForStorage(streamMessage: StreamMessage, { interval, timeout, count, messageMatchFn }?: {
        interval?: number;
        timeout?: number;
        count?: number;
        messageMatchFn?: (msgTarget: StreamMessage, msgGot: StreamMessage) => boolean;
    }): Promise<void>;
    startKeyExchange(): Promise<void>;
    stopKeyExchange(): Promise<void>;
    setPublishProxy(streamDefinition: StreamDefinition, nodeId: string): Promise<void>;
    removePublishProxy(streamDefinition: StreamDefinition, nodeId: string): Promise<void>;
    setPublishProxies(streamDefinition: StreamDefinition, nodeIds: string[]): Promise<void>;
    removePublishProxies(streamDefinition: StreamDefinition, nodeIds: string[]): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
}
