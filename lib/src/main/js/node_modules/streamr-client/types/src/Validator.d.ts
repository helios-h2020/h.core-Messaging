import { StreamMessage, StreamMessageValidator, StreamMessageError } from 'streamr-client-protocol';
import { Stoppable } from './utils/Stoppable';
import { Context } from './utils/Context';
import { StreamEndpointsCached } from './StreamEndpointsCached';
import { SubscribeConfig, CacheConfig } from './Config';
export declare class SignatureRequiredError extends StreamMessageError {
    constructor(streamMessage: StreamMessage, code?: string);
}
/**
 * Wrap StreamMessageValidator in a way that ensures it can validate in parallel but
 * validation is guaranteed to resolve in the same order they were called
 * Handles caching remote calls
 */
export default class Validator extends StreamMessageValidator implements Stoppable, Context {
    private options;
    private cacheOptions;
    id: string;
    debug: import("debug").Debugger;
    isStopped: boolean;
    private doValidation;
    constructor(context: Context, streamEndpoints: StreamEndpointsCached, options: SubscribeConfig, cacheOptions: CacheConfig);
    private cachedVerify;
    orderedValidate: ((msg: StreamMessage<unknown>) => Promise<Promise<void>>) & {
        clear(): void;
    };
    validate(msg: StreamMessage): Promise<void>;
    stop(): void;
}
