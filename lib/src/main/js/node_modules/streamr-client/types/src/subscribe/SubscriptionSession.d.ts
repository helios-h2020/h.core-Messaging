import { DependencyContainer } from 'tsyringe';
import { StreamMessage, StreamPartID } from 'streamr-client-protocol';
import { Stoppable } from '../utils/Stoppable';
import { Context } from '../utils/Context';
import Signal from '../utils/Signal';
import { MessageStream } from './MessageStream';
import { Subscription } from './Subscription';
import BrubeckNode from '../BrubeckNode';
/**
 * Manages adding & removing subscriptions to node as needed.
 * A session contains one or more subscriptions to a single streamId + streamPartition pair.
 */
export default class SubscriptionSession<T> implements Context, Stoppable {
    id: string;
    debug: import("debug").Debugger;
    readonly streamPartId: StreamPartID;
    /** active subs */
    subscriptions: Set<Subscription<T>>;
    pendingRemoval: WeakSet<Subscription<T>>;
    isRetired: boolean;
    isStopped: boolean;
    pipeline: MessageStream<T, StreamMessage<T>, StreamMessage<T>>;
    node: BrubeckNode;
    onRetired: {
        (): Promise<undefined>;
        <ReturnType_1>(this: ReturnType_1, cb: () => unknown): ReturnType_1;
    } & import("../utils/Plugin").Methods<Signal<[]>>;
    constructor(context: Context, streamPartId: StreamPartID, container: DependencyContainer);
    private retire;
    private onError;
    distributeMessage(src: AsyncGenerator<StreamMessage<T>>): AsyncGenerator<StreamMessage<T>, void, unknown>;
    private onMessageInput;
    private subscribe;
    private unsubscribe;
    updateNodeSubscriptions: (() => Promise<void>) & {
        next: () => Promise<void>;
        isActive: () => boolean;
        getCurrentStep(): Promise<void>;
        readonly activeCount: number;
        readonly pendingCount: number;
        setError(err: Error): void;
        getError(): Error | undefined;
        clearError(): Error | undefined;
    };
    updateSubscriptions(): Promise<void>;
    shouldBeSubscribed(): boolean;
    stop(): Promise<void>;
    has(sub: Subscription<T>): boolean;
    waitForNeighbours(numNeighbours?: number, timeout?: number): Promise<boolean>;
    /**
     * Add subscription & appropriate connection handle.
     */
    add(sub: Subscription<T>): Promise<void>;
    /**
     * Remove subscription & appropriate connection handle.
     */
    remove(sub: Subscription<T>): Promise<void>;
    /**
     * Remove all subscriptions & subscription connection handles
     */
    removeAll(): Promise<void>;
    /**
     * How many subscriptions
     */
    count(): number;
}
