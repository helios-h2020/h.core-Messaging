import { NetworkNodeOptions, MetricsContext } from 'streamr-network';
import { Context } from './utils/Context';
import { StreamMessage, StreamPartID } from 'streamr-client-protocol';
import { DestroySignal } from './DestroySignal';
import Ethereum from './Ethereum';
export interface NetworkNodeStub {
    getNodeId: () => string;
    addMessageListener: (listener: (msg: StreamMessage) => void) => void;
    removeMessageListener: (listener: (msg: StreamMessage) => void) => void;
    subscribe: (streamPartId: StreamPartID) => void;
    unsubscribe: (streamPartId: StreamPartID) => void;
    publish: (streamMessage: StreamMessage) => void;
    getStreamParts: () => Iterable<StreamPartID>;
    getNeighbors: () => ReadonlyArray<string>;
    getNeighborsForStreamPart: (streamPartId: StreamPartID) => ReadonlyArray<string>;
    getRtt: (nodeId: string) => number | undefined;
    setExtraMetadata: (metadata: Record<string, unknown>) => void;
    getMetricsContext: () => MetricsContext;
}
/**
 * Wrap a network node.
 * Lazily creates & starts node on first call to getNode().
 */
export default class BrubeckNode implements Context {
    private destroySignal;
    private ethereum;
    private cachedNode?;
    private options;
    id: string;
    debug: import("debug").Debugger;
    private startNodeCalled;
    private startNodeComplete;
    constructor(context: Context, destroySignal: DestroySignal, ethereum: Ethereum, options: NetworkNodeOptions);
    private assertNotDestroyed;
    private initNode;
    private generateId;
    /**
     * Stop network node, or wait for it to stop if already stopping.
     * Subsequent calls to getNode/start will fail.
     */
    private destroy;
    /**
     * Start network node, or wait for it to start if already started.
     */
    private startNodeTask;
    startNode: () => Promise<unknown>;
    /**
     * Get started network node.
     */
    getNode: () => Promise<NetworkNodeStub>;
    getNodeId(): Promise<string>;
    /**
     * Calls publish on node after starting it.
     * Basically a wrapper around: (await getNode()).publish(â€¦)
     * but will be sync in case that node is already started.
     * Zalgo intentional. See below.
     */
    publishToNode(streamMessage: StreamMessage): void | Promise<void>;
    openPublishProxyConnectionOnStreamPart(streamPartId: StreamPartID, nodeId: string): Promise<void>;
    closePublishProxyConnectionOnStreamPart(streamPartId: StreamPartID, nodeId: string): Promise<void>;
}
