import { BytesLike } from '@ethersproject/bytes';
import { Contract, ContractReceipt } from '@ethersproject/contracts';
import StreamrEthereum from '../Ethereum';
import DataUnionAPI from './index';
import { EthereumAddress } from 'streamr-client-protocol';
import { AmbMessageHash } from './DataUnion';
export default class Contracts {
    ethereum: StreamrEthereum;
    factoryMainnetAddress: EthereumAddress;
    factorySidechainAddress: EthereumAddress;
    templateMainnetAddress: EthereumAddress;
    templateSidechainAddress: EthereumAddress;
    binanceAdapterAddress: EthereumAddress;
    binanceSmartChainAMBAddress: EthereumAddress;
    cachedSidechainAmb?: Contract | Promise<Contract>;
    constructor(client: DataUnionAPI);
    /**
     * Check if there is a data union in given address, return its version
     * @returns 0 if target address is not a Data Union contract
     */
    getVersion(contractAddress: EthereumAddress): Promise<number>;
    getMainnetContractReadOnly(contractAddress: EthereumAddress): Promise<Contract>;
    getMainnetContract(contractAddress: EthereumAddress): Promise<Contract>;
    getSidechainContract(contractAddress: EthereumAddress): Promise<Contract>;
    getSidechainContractReadOnly(contractAddress: EthereumAddress): Promise<Contract>;
    getSidechainAmb(): Promise<Contract>;
    getMainnetAmb(): Promise<Contract>;
    getBinanceAdapter(): Promise<Contract>;
    getBinanceAdapterReadOnly(): Contract;
    getBinanceSmartChainAmb(binanceSenderPrivateKey: BytesLike): Promise<Contract>;
    requiredSignaturesHaveBeenCollected(messageHash: AmbMessageHash): Promise<any>;
    /**
     * Move signatures from sidechain to mainnet
     * @returns null if message was already transported, ELSE the mainnet AMB signature execution transaction receipt
     */
    transportSignaturesForMessage(messageHash: string, ethersOptions?: {}): Promise<ContractReceipt | null>;
}
