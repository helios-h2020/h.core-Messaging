/// <reference types="node" />
/**
 * New Brubeck Configuration.
 * Old Config in ConfigBase.
 * TODO: Disolve ConfigBase.
 */
import 'reflect-metadata';
import type { NetworkNodeOptions } from 'streamr-network';
import type { InspectOptions } from 'util';
import type { StrictStreamrClientConfig, StreamrClientConfig } from './ConfigBase';
export declare type BrubeckClientConfig = StreamrClientConfig & {
    network?: Omit<Partial<NetworkNodeOptions>, 'metricsContext'>;
    debug?: Partial<DebugConfig>;
};
export { NetworkNodeOptions as NetworkNodeConfig };
export declare type DebugConfig = {
    inspectOpts: InspectOptions;
};
export declare type StrictBrubeckClientConfig = StrictStreamrClientConfig & {
    network: NetworkNodeOptions;
    debug: DebugConfig;
};
/**
 * DI Injection tokens for pieces of config.
 * tsyringe needs a concrete value to use as the injection token.
 * In the case of interfaces & types, these have no runtime value
 * so we have to introduce some token to use for their injection.
 * These symbols represent subsections of the full config.
 *
 * For example:
 * config.ethereum can be injected with a token like: @inject(Config.Ethereum)
 */
declare const BrubeckConfigInjection: {
    Root: symbol;
    Auth: symbol;
    Ethereum: symbol;
    Network: symbol;
    Connection: symbol;
    Subscribe: symbol;
    Publish: symbol;
    Cache: symbol;
    StorageNodeRegistry: symbol;
    Encryption: symbol;
};
export * from './ConfigBase';
export { BrubeckConfigInjection as Config };
declare const BRUBECK_CLIENT_DEFAULTS: {
    debug: {
        inspectOpts: {
            depth: number;
            maxStringLength: number;
        };
    };
    network: {
        trackers: {
            id: string;
            ws: string;
            http: string;
        }[];
        acceptProxyConnections: boolean;
    };
};
export { BRUBECK_CLIENT_DEFAULTS as DEFAULTS };
export default function BrubeckConfig(config: BrubeckClientConfig): StrictBrubeckClientConfig;
