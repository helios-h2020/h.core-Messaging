/// <reference types="node" />
import crypto from 'crypto';
import { O } from 'ts-toolbelt';
import { StreamMessage, StreamMessageError, ValidationError } from 'streamr-client-protocol';
export declare class StreamMessageProcessingError extends StreamMessageError {
    constructor(message: string | undefined, streamMessage: StreamMessage);
}
export declare class UnableToDecryptError extends StreamMessageProcessingError {
    constructor(message: string | undefined, streamMessage: StreamMessage);
}
declare class InvalidGroupKeyError extends ValidationError {
    groupKey?: any;
    constructor(message: string, groupKey?: any);
}
declare type GroupKeyObject = {
    id: string;
    hex: string;
    data: Uint8Array;
};
interface GroupKey extends GroupKeyObject {
}
export declare type GroupKeyish = GroupKey | GroupKeyObject | ConstructorParameters<typeof GroupKey>;
declare class GroupKey {
    static InvalidGroupKeyError: typeof InvalidGroupKeyError;
    static validate(maybeGroupKey: GroupKey): void;
    id: string;
    hex: string;
    data: Uint8Array;
    constructor(groupKeyId: string, groupKeyBufferOrHexString: Uint8Array | string);
    equals(other: GroupKey): boolean;
    toString(): string;
    toArray(): string[];
    serialize(): string;
    static generate(id?: string): GroupKey;
    static from(maybeGroupKey: GroupKeyish): GroupKey;
}
export { GroupKey };
declare class EncryptionUtilBase {
    static validatePublicKey(publicKey: crypto.KeyLike): void;
    /**
     * Returns a Buffer or a hex String
     */
    static encryptWithPublicKey(plaintextBuffer: Uint8Array, publicKey: crypto.KeyLike, outputInHex: true): string;
    static encryptWithPublicKey(plaintextBuffer: Uint8Array, publicKey: crypto.KeyLike): string;
    static encryptWithPublicKey(plaintextBuffer: Uint8Array, publicKey: crypto.KeyLike, outputInHex: false): Buffer;
    static encrypt(data: Uint8Array, groupKey: GroupKey): string;
    static decrypt(ciphertext: string, groupKey: GroupKey): Buffer;
    static encryptStreamMessage(streamMessage: StreamMessage, groupKey: GroupKey, nextGroupKey?: GroupKey): void;
    static decryptStreamMessage(streamMessage: StreamMessage, groupKey: GroupKey): null;
}
declare type InitializedEncryptionUtil = O.Overwrite<EncryptionUtil, {
    privateKey: string;
    publicKey: string;
}>;
export default class EncryptionUtil extends EncryptionUtilBase {
    /**
     * Creates a new instance + waits for ready.
     * Convenience.
     */
    static create(): Promise<EncryptionUtil>;
    privateKey: string | undefined;
    publicKey: string | undefined;
    private _generateKeyPairPromise;
    onReady(): Promise<void>;
    isReady(this: EncryptionUtil): this is InitializedEncryptionUtil;
    decryptWithPrivateKey(ciphertext: string | Uint8Array, isHexString?: boolean): Buffer;
    getPublicKey(): string;
    _generateKeyPair(): Promise<void>;
    __generateKeyPair(): Promise<void>;
    _keyPairServer(): Promise<void>;
    _keyPairBrowser(): Promise<void>;
}
