/**
 * Public Resends API
 */
import { DependencyContainer } from 'tsyringe';
import { MessageRef, StreamPartID } from 'streamr-client-protocol';
import { Context } from '../utils/Context';
import { MessageStream, MessageStreamOnMessage } from './MessageStream';
import { StorageNodeRegistry } from '../StorageNodeRegistry';
import { StreamEndpoints } from '../StreamEndpoints';
import { Rest } from '../Rest';
import { StreamIDBuilder } from '../StreamIDBuilder';
import { StreamDefinition } from '../types';
export declare type ResendRef = MessageRef | {
    timestamp: number | Date | string;
    sequenceNumber?: number;
};
export declare type ResendLastOptions = {
    last: number;
};
export declare type ResendFromOptions = {
    from: ResendRef;
    publisherId?: string;
};
export declare type ResendRangeOptions = {
    from: ResendRef;
    to: ResendRef;
    msgChainId?: string;
    publisherId?: string;
};
export declare type ResendOptions = ResendLastOptions | ResendFromOptions | ResendRangeOptions;
export default class Resend implements Context {
    private storageNodeRegistry;
    private streamIdBuilder;
    private streamEndpoints;
    private rest;
    private container;
    id: string;
    debug: import("debug").Debugger;
    constructor(context: Context, storageNodeRegistry: StorageNodeRegistry, streamIdBuilder: StreamIDBuilder, streamEndpoints: StreamEndpoints, rest: Rest, container: DependencyContainer);
    /**
     * Call last/from/range as appropriate based on arguments
     */
    resend<T>(streamDefinition: StreamDefinition, options: ResendOptions, onMessage?: MessageStreamOnMessage<T>): Promise<MessageStream<T>>;
    private resendMessages;
    private fetchStream;
    private last;
    from<T>(streamPartId: StreamPartID, { fromTimestamp, fromSequenceNumber, publisherId }: {
        fromTimestamp: number;
        fromSequenceNumber?: number;
        publisherId?: string;
    }): Promise<MessageStream<T>>;
    range<T>(streamPartId: StreamPartID, { fromTimestamp, fromSequenceNumber, toTimestamp, toSequenceNumber, publisherId, msgChainId }: {
        fromTimestamp: number;
        fromSequenceNumber?: number;
        toTimestamp: number;
        toSequenceNumber?: number;
        publisherId?: string;
        msgChainId?: string;
    }): Promise<MessageStream<T>>;
    stop(): Promise<void>;
}
