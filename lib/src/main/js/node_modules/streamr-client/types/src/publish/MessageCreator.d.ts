import { StreamMessage, StreamMessageEncrypted, StreamMessageSigned, StreamID } from 'streamr-client-protocol';
import { LimitAsyncFnByKey } from '../utils';
import { Stoppable } from '../utils/Stoppable';
import { CacheConfig } from '../Config';
import Ethereum from '../Ethereum';
import StreamPartitioner from './StreamPartitioner';
export declare type MessageCreateOptions<T = unknown> = {
    content: T;
    timestamp: number;
    partitionKey?: string | number;
    msgChainId?: string;
};
export interface IMessageCreator {
    create: <T>(streamId: StreamID, options: MessageCreateOptions<T>) => Promise<StreamMessage<T>>;
    stop: () => Promise<void> | void;
}
export declare class StreamMessageCreatorAnonymous implements IMessageCreator {
    create<T>(_streamId: string, _options: MessageCreateOptions<T>): Promise<StreamMessage<T>>;
    stop(): void;
}
/**
 * Create StreamMessages from metadata.
 */
export default class StreamMessageCreator implements IMessageCreator, Stoppable {
    private streamPartitioner;
    private ethereum;
    private cacheOptions;
    isStopped: boolean;
    queue: ReturnType<typeof LimitAsyncFnByKey>;
    getMsgChain: ((args_0: import("streamr-client-protocol").StreamPartID, args_1: import("./MessageChain").MessageChainOptions) => import("./MessageChain").default) & {
        clear: () => void;
        clearMatching: (matchFn: (key: string) => boolean) => void;
    };
    constructor(streamPartitioner: StreamPartitioner, ethereum: Ethereum, cacheOptions: CacheConfig);
    create<T = unknown>(streamId: StreamID, { content, timestamp, partitionKey, msgChainId, ...opts }: MessageCreateOptions<T>): Promise<StreamMessageSigned<T> | StreamMessageEncrypted<T>>;
    start(): Promise<void>;
    stop(): Promise<void>;
}
