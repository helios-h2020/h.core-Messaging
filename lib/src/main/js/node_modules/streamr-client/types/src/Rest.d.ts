/// <reference types="node" />
/**
 * More ergonomic wrapper around fetch/authFetch
 */
import { DependencyContainer } from 'tsyringe';
import { Debugger } from './utils/log';
import { ConnectionConfig } from './Config';
import { Context } from './utils/Context';
import { Readable } from 'stream';
import Session from './Session';
export declare type FetchOptions = {
    query?: any;
    useSession?: boolean;
    options?: any;
    requireNewToken?: boolean;
    debug?: Debugger;
    restUrl?: string;
};
export declare type UrlParts = (string | number)[];
export declare const createQueryString: (query: Record<string, any>) => string;
export declare class Rest implements Context {
    private container;
    private options;
    id: string;
    debug: import("debug").Debugger;
    constructor(context: Context, container: DependencyContainer, options: ConnectionConfig);
    getUrl(urlParts: UrlParts, query?: {}, restUrl?: string): URL;
    get session(): Session;
    fetch<T extends object>(urlParts: UrlParts, { query, useSession, options, requireNewToken, debug, restUrl }: FetchOptions): Promise<T>;
    request<T extends object>(urlParts: UrlParts, { query, useSession, options, requireNewToken, debug, restUrl }: FetchOptions): Promise<import("node-fetch").Response>;
    post<T extends object>(urlParts: UrlParts, body?: any, options?: FetchOptions): Promise<T>;
    get<T extends object>(urlParts: UrlParts, options?: FetchOptions): Promise<T>;
    put<T extends object>(urlParts: UrlParts, body?: any, options?: FetchOptions): Promise<T>;
    del<T extends object>(urlParts: UrlParts, options?: FetchOptions): Promise<T>;
    stream(urlParts: UrlParts, options?: FetchOptions, abortController?: AbortController): Promise<Readable>;
    fetchStream(url: string, opts?: {}, abortController?: AbortController): Promise<Readable>;
}
