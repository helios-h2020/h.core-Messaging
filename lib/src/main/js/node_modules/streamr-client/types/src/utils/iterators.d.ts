import { MaybeAsync } from '../types';
export declare const debug: import("debug").Debugger;
export declare type ICancelable = {
    cancel(err?: Error): Promise<void>;
    isCancelled: () => boolean;
};
export declare type Cancelable<T> = T & ICancelable;
export declare type MaybeCancelable<T> = T | Cancelable<T>;
/**
 * Allows injecting a function to execute after an iterator finishes.
 * Executes finally function even if generator not started.
 * Returns new generator.
 */
declare type OnFinallyFn = MaybeAsync<(err?: Error) => void>;
export declare function iteratorFinally<T>(// eslint-disable-line no-redeclare
iterable: MaybeCancelable<AsyncIterable<T> | AsyncGenerator<T>>, onFinally?: OnFinallyFn): AsyncGenerator<T, any, unknown>;
/**
 * Creates a generator that can be cancelled and perform optional final cleanup.
 * const [cancal, generator] = CancelableGenerator(iterable, onFinally)
 */
export declare function CancelableGenerator<T>(iterable: MaybeCancelable<AsyncIterable<T> | AsyncGenerator<T>>, onFinally?: OnFinallyFn, { timeout }?: {
    timeout?: number | undefined;
}): Cancelable<AsyncGenerator<T, any, unknown>>;
export {};
