//filter will reemit the data if cb(err,pass) pass is truthy

// reduce is more tricky
// maybe we want to group the reductions or emit progress updates occasionally
// the most basic reduce just emits one 'data' event after it has recieved 'end'


var through = require('through')
var Decoder = require('string_decoder').StringDecoder

module.exports = split

//TODO pass in a function to map across the lines.

function split (matcher, mapper, options) {
  var decoder = new Decoder()
  var soFar = ''
  var maxLength = options && options.maxLength;
  var trailing = options && options.trailing === false ? false : true
  if('function' === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = /\r?\n/

  /*
  console.log("debug: type of matcher:" + (typeof matcher))
  if (mapper) {
      console.log("debug: mapper=" + mapper.name + "," + mapper)
  } else {
      console.log("debug: mapper was null")
  }
  if (matcher) {
      console.log("debug: matcher=" + matcher.toString())
  } else {
      console.log("debug: matcher was null")
  }
  */

  function emit(stream, piece) {
    if(mapper) {
      try {
        // console.log("debug: piece before mapper=" + piece)
        piece = mapper(piece)
        // console.log("debug: piece after mapper=" + piece.toString())
      }
      catch (err) {
        console.log("debug: ******error detected!\n")
        console.log("debug: piece=" + piece)
        console.log("debug: ---------")
        return stream.emit('error', err)
      }
      if('undefined' !== typeof piece)
        stream.queue(piece)
    }
    else
      stream.queue(piece)
  }

  function next (stream, buffer) {
    // console.log("debug: soFar="+ soFar)
    // console.log("debug: buffer=" + buffer)
    // console.log("debug: matcher=" + matcher)

    /*
    if(buffer != null) {
      i = buffer.indexOf("}{")
      if(i != -1) {
        // console.log("debug: split: found }{ =" + buffer)
        //  buffer = buffer.replace("}{", "},{")
      }
    }
    */
    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)
    // console.log("debug: next pieces=" + pieces)
    soFar = pieces.pop()

    if (maxLength && soFar.length > maxLength)
      return stream.emit('error', new Error('maximum buffer reached'))

    for (var i = 0; i < pieces.length; i++) {
      var piece = pieces[i]
      emit(stream, piece)
    }
  }

  return through(function (b) {
    next(this, decoder.write(b))
  },
  function () {
    if(decoder.end)
      next(this, decoder.end())
    if(trailing && soFar != null)
      emit(this, soFar)
    this.queue(null)
  })
}
