(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.CancelablePromise = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cancelable = cancelable;
  _exports.CancelablePromise = CancelablePromise;
  _exports.default = void 0;

  function createCallback(onResult, options) {
    if (onResult) {
      return function (arg) {
        if (!options.isCanceled) {
          return onResult(arg);
        }

        return arg;
      };
    }
  }

  function makeCancelable(promise, options) {
    var methods = {
      then: function then(onSuccess, onError) {
        return makeCancelable(promise.then(createCallback(onSuccess, options), createCallback(onError, options)), options);
      },
      catch: function _catch(onError) {
        return makeCancelable(promise.catch(createCallback(onError, options)), options);
      },
      finally: function _finally(onFinally, runWhenCanceled) {
        if (runWhenCanceled) {
          if (!options.finallyList) {
            options.finallyList = [];
          }

          options.finallyList.push(onFinally);
        }

        return makeCancelable(promise.finally(function () {
          if (runWhenCanceled) {
            options.finallyList = options.finallyList.filter(function (callback) {
              return callback !== onFinally;
            });
          }

          return onFinally();
        }), options);
      },
      cancel: function cancel() {
        options.isCanceled = true;

        for (var _i = 0, _arr = [options.onCancelList, options.finallyList]; _i < _arr.length; _i++) {
          var callbacks = _arr[_i];

          if (callbacks) {
            while (callbacks.length) {
              var onCancel = callbacks.shift();

              if (typeof onCancel === 'function') {
                onCancel();
              }
            }
          }
        }
      },
      isCanceled: function isCanceled() {
        return options.isCanceled === true;
      }
    };
    return {
      then: methods.then.bind(undefined),
      catch: methods.catch.bind(undefined),
      finally: methods.finally.bind(undefined),
      cancel: methods.cancel.bind(undefined),
      isCanceled: methods.isCanceled.bind(undefined)
    };
  }

  function cancelable(promise) {
    return makeCancelable(promise, {});
  }

  function CancelablePromise(executor) {
    var onCancelList = [];
    return makeCancelable(new Promise(function (resolve, reject) {
      return executor(resolve, reject, function (onCancel) {
        onCancelList.push(onCancel);
      });
    }), {
      onCancelList: onCancelList
    });
  }

  CancelablePromise.all = function (iterable) {
    return cancelable(Promise.all(iterable));
  };

  CancelablePromise.allSettled = function (iterable) {
    return cancelable(Promise.allSettled(iterable));
  };

  CancelablePromise.race = function (iterable) {
    return cancelable(Promise.race(iterable));
  };

  CancelablePromise.resolve = function (value) {
    return cancelable(Promise.resolve(value));
  };

  CancelablePromise.reject = function (value) {
    return cancelable(Promise.reject(value));
  };

  var _default = CancelablePromise;
  _exports.default = _default;
});